<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dictation Quest — Corti API Roadmap</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0a0a1a;
      overflow: hidden;
      font-family: 'Press Start 2P', monospace;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      cursor: default;
      user-select: none;
    }

    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    /* HUD overlay */
    #hud {
      position: absolute;
      top: 0; left: 0; right: 0;
      padding: 16px 24px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
      pointer-events: none;
      z-index: 10;
    }

    #hud .title {
      font-size: 20px;
      color: #f0c040;
      text-shadow: 2px 2px 0 #000;
      letter-spacing: 2px;
    }

    #hud .subtitle {
      font-size: 12px;
      color: #a0a0b0;
      margin-top: 6px;
      text-shadow: 1px 1px 0 #000;
    }

    #hud .quest-info {
      text-align: right;
      font-size: 12px;
      color: #80d080;
      text-shadow: 1px 1px 0 #000;
    }

    /* Info panel for roadmap items */
    #info-panel {
      position: absolute;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      max-width: 800px;
      width: 90%;
      background: rgba(10, 10, 30, 0.95);
      border: 4px solid #f0c040;
      border-radius: 6px;
      padding: 28px 32px;
      z-index: 20;
      display: none;
      box-shadow: 0 0 40px rgba(240, 192, 64, 0.3), inset 0 0 20px rgba(0,0,0,0.5);
    }

    #info-panel.visible {
      display: block;
      animation: panelSlideUp 0.2s ease-out;
    }

    @keyframes panelSlideUp {
      from { transform: translateX(-50%) translateY(20px); opacity: 0; }
      to { transform: translateX(-50%) translateY(0); opacity: 1; }
    }

    #info-panel .panel-status {
      font-size: 14px;
      color: #80d080;
      margin-bottom: 12px;
      text-transform: uppercase;
    }

    #info-panel .panel-status.upcoming {
      color: #f0c040;
    }

    #info-panel .panel-title {
      font-size: 20px;
      color: #fff;
      margin-bottom: 16px;
      text-shadow: 1px 1px 0 #000;
      line-height: 1.8;
    }

    #info-panel .panel-desc {
      font-size: 13px;
      color: #c0c0d0;
      line-height: 2.2;
      text-shadow: 1px 1px 0 #000;
    }

    #info-panel .panel-close {
      position: absolute;
      top: 12px;
      right: 16px;
      font-size: 14px;
      color: #f0c040;
      cursor: pointer;
      pointer-events: all;
    }

    #info-panel .panel-number {
      display: inline-block;
      background: #f0c040;
      color: #0a0a1a;
      padding: 4px 10px;
      margin-right: 10px;
      font-size: 16px;
    }

    /* Milestone banner */
    #milestone-banner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 25;
      text-align: center;
      display: none;
      pointer-events: none;
    }

    #milestone-banner.visible {
      display: block;
      animation: milestonePulse 0.5s ease-out;
    }

    @keyframes milestonePulse {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      60% { transform: translate(-50%, -50%) scale(1.1); }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }

    #milestone-banner .banner-text {
      font-size: 28px;
      color: #f0c040;
      text-shadow: 3px 3px 0 #000, 0 0 20px rgba(240,192,64,0.5);
      line-height: 2;
      white-space: nowrap;
    }

    /* Dragon slaying screen */
    #dragon-screen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.9);
      z-index: 30;
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }

    #dragon-screen.visible {
      display: flex;
      animation: fadeIn 1s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    #dragon-screen canvas {
      margin-bottom: 20px;
    }

    /* Controls hint */
    #controls-hint {
      position: absolute;
      bottom: 16px;
      right: 24px;
      font-size: 12px;
      color: #606070;
      text-shadow: 1px 1px 0 #000;
      z-index: 10;
      pointer-events: none;
      line-height: 2.2;
      text-align: right;
    }

    /* Minimap */
    #minimap {
      position: absolute;
      top: 80px;
      right: 20px;
      border: 3px solid #f0c040;
      z-index: 10;
      background: rgba(0,0,0,0.7);
      image-rendering: pixelated;
    }

    /* Title screen */
    #title-screen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(10, 10, 26, 0.92);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 50;
      cursor: pointer;
    }

    /* Loading screen */
    #loading {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #0a0a1a;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }

    #loading .load-title {
      font-size: 32px;
      color: #f0c040;
      margin-bottom: 32px;
      text-shadow: 3px 3px 0 #000;
    }

    #loading .load-bar-outer {
      width: 400px;
      height: 24px;
      border: 3px solid #f0c040;
      background: #1a1a2a;
    }

    #loading .load-bar-inner {
      height: 100%;
      width: 0%;
      background: #f0c040;
      transition: width 0.3s;
    }

    #loading .load-text {
      font-size: 14px;
      color: #808090;
      margin-top: 16px;
    }

    /* Interaction prompt above items */
    .interact-prompt {
      position: absolute;
      font-size: 14px;
      color: #f0c040;
      text-shadow: 1px 1px 0 #000;
      pointer-events: none;
      z-index: 5;
      animation: bobUpDown 1s ease-in-out infinite;
    }

    @keyframes bobUpDown {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-4px); }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game-canvas"></canvas>
    <canvas id="minimap" width="200" height="150"></canvas>

    <div id="hud">
      <div>
        <div class="title">DICTATION QUEST</div>
        <div class="subtitle">The Quest for Clinical Dictation</div>
      </div>
      <div class="quest-info">
        <div id="quest-status">QUEST: Slay the Dragon</div>
        <div id="quest-progress" style="margin-top:4px;"></div>
        <div id="coin-counter" style="margin-top:4px; color:#f0d060;"></div>
      </div>
    </div>

    <div id="info-panel">
      <!-- Panel auto-closes when walking away -->
      <div class="panel-status" id="panel-status"></div>
      <div class="panel-title" id="panel-title"></div>
      <div class="panel-desc" id="panel-desc"></div>
    </div>

    <div id="milestone-banner">
      <div class="banner-text" id="banner-text"></div>
    </div>

    <div id="controls-hint">
      WASD / ARROWS — Move
    </div>

    <!-- Title / Intro screen -->
    <div id="title-screen" style="display:none;">
      <div style="text-align:center;">
        <div style="font-size:48px; color:#f0c040; text-shadow:4px 4px 0 #000, 0 0 40px rgba(240,192,64,0.4); margin-bottom:32px; line-height:1.6;">DICTATION QUEST</div>
        <div style="font-size:16px; color:#a0a0b0; text-shadow:2px 2px 0 #000; margin-bottom:40px; line-height:2.4; max-width:700px;">
          The best foundation for building<br>clinical dictation products,<br>delivered as an API.
        </div>
        <div style="font-size:14px; color:#c0c0d0; text-shadow:1px 1px 0 #000; margin-bottom:8px; line-height:2.2;">Follow Bard the Bowman on an epic quest</div>
        <div style="font-size:14px; color:#c0c0d0; text-shadow:1px 1px 0 #000; margin-bottom:48px; line-height:2.2;">down the Corti API roadmap.</div>
        <div id="start-btn" style="font-size:20px; color:#f0c040; cursor:pointer; animation: bobUpDown 1.5s ease-in-out infinite; text-shadow:2px 2px 0 #000;">[ PRESS ANY KEY TO BEGIN ]</div>
        <div style="font-size:12px; color:#505060; margin-top:24px; text-shadow:1px 1px 0 #000;">WASD or Arrow Keys to move</div>
      </div>
    </div>

    <div id="loading">
      <div class="load-title">DICTATION QUEST</div>
      <div class="load-bar-outer">
        <div class="load-bar-inner" id="load-bar"></div>
      </div>
      <div class="load-text" id="load-text">Generating world...</div>
    </div>
  </div>

  <script>
// ============================================================
// DICTATION QUEST — 2D Pixel Art Roadmap Quest
// ============================================================

const TILE_SIZE = 32;
const MAP_COLS = 80;
const MAP_ROWS = 60;
const CAMERA_SMOOTH = 0.1;
const ZOOM = 2; // 2x zoom so the character is clearly visible

// Directions: 0=N, 1=NE, 2=E, 3=SE, 4=S, 5=SW, 6=W, 7=NW
const DIR_NAMES = ['n','ne','e','se','s','sw','w','nw'];
const DIR_OFFSETS = [
  [0,-1],[1,-1],[1,0],[1,1],[0,1],[-1,1],[-1,0],[-1,-1]
];

// ============================================================
// ROADMAP DATA
// ============================================================
// Winding adventure path layout:
// Start(4,10) → East to item1(16,10) → East to item2(30,10) → South to item3(30,24)
// → East to milestone1(44,24) → North to item4(44,12) → East to item5(58,12)
// → South to item6(58,30) → West to item7(44,30) → South to dragon(44,44)
const ROADMAP_ITEMS = [
  {
    id: 1,
    title: 'Clinical-grade STT Models',
    status: 'shipped',
    description: 'Foundation. High-accuracy medical STT across supported languages, purpose-built for clinical terminology and high-stakes workflows.',
    mapX: 16, mapY: 10,
    icon: 'tower'
  },
  {
    id: 2,
    title: 'Command Framework',
    status: 'shipped',
    description: 'Define voice commands with dynamic parameters to navigate, edit, and control application workflows. Gives clinicians precise control without breaking dictation flow.',
    mapX: 30, mapY: 10,
    icon: 'tower'
  },
  {
    id: 3,
    title: 'Output Formatting',
    status: 'shipped',
    description: 'Configurable formatting for dates, times, numbers, units, measurements, ranges, and ordinals. Automatic capitalization and punctuation. Output reads like a clinical document, not a raw transcript.',
    mapX: 30, mapY: 24,
    icon: 'tower'
  },
  {
    id: 'milestone1',
    title: 'EMPOWERED TO BUILD\nA DRAGON REPLACEMENT',
    status: 'milestone',
    description: '',
    mapX: 44, mapY: 24,
    icon: 'bow'
  },
  {
    id: 4,
    title: 'Advanced Formatting',
    status: 'upcoming',
    description: 'Improved handling of key homophones (e.g., "period", "colon"). Better date and number localization.',
    mapX: 44, mapY: 12,
    icon: 'chest'
  },
  {
    id: 5,
    title: 'Advanced Speed',
    status: 'upcoming',
    description: 'Real-time partial transcription as the user speaks. Essential for building responsive dictation UIs where text appears on screen with minimal perceived latency.',
    mapX: 58, mapY: 12,
    icon: 'chest'
  },
  {
    id: 6,
    title: 'Advanced Commands',
    status: 'upcoming',
    description: 'Wildcard variables for templated command systems beyond static phrase matching. Non-verbal command anchors that map physical device inputs (foot pedals, hotkeys, button presses) to actions in the transcription stream.',
    mapX: 58, mapY: 38,
    icon: 'chest'
  },
  {
    id: 7,
    title: 'Advanced Customization',
    status: 'upcoming',
    description: 'Organization-specific tuning. Custom vocabulary handles recognition (getting the model to hear the right terms), replacement rules handle formatting (standardizing what appears in output). Together they let customers tailor the full pipeline to their environment.',
    mapX: 44, mapY: 38,
    icon: 'chest'
  },
  {
    id: 'milestone2',
    title: 'SLAY THE DRAGON\nONCE AND FOR ALL',
    status: 'milestone',
    description: '',
    mapX: 44, mapY: 52,
    icon: 'dragon'
  }
];

// ============================================================
// PIXEL ART GENERATOR — All sprites generated procedurally
// ============================================================

class PixelArt {
  static createCanvas(w, h) {
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    return { canvas: c, ctx: c.getContext('2d') };
  }

  // Draw a single pixel (scaled)
  static px(ctx, x, y, color, scale = 1) {
    ctx.fillStyle = color;
    ctx.fillRect(x * scale, y * scale, scale, scale);
  }

  // Load character sprites from PixelLab-generated PNGs
  // Returns a promise that resolves to {idle: {dir: Image}, walk: {dir: [Image]}}
  static async loadCharacterSprites() {
    const PIXELLAB_DIR_MAP = {
      'n': 'north',
      'ne': 'north-east',
      'e': 'east',
      'se': 'south-east',
      's': 'south',
      'sw': 'south-west',
      'w': 'west',
      'nw': 'north-west'
    };
    const WALK_FRAMES = 6;
    const basePath = 'assets/character';

    const loadImg = (src) => new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error('Failed to load: ' + src));
      img.src = src;
    });

    const sprites = {};
    const promises = [];

    for (const dir of DIR_NAMES) {
      const plDir = PIXELLAB_DIR_MAP[dir];
      sprites[dir] = [];

      // Load walk animation frames (6 frames)
      for (let f = 0; f < WALK_FRAMES; f++) {
        const frameStr = String(f).padStart(3, '0');
        const path = `${basePath}/animations/walking-4-frames/${plDir}/frame_${frameStr}.png`;
        const idx = f;
        const d = dir;
        promises.push(
          loadImg(path).then(img => { sprites[d][idx] = img; })
        );
      }
    }

    await Promise.all(promises);

    // Also load idle frames (rotation images) as the stand-still pose
    const idleSprites = {};
    const idlePromises = [];
    for (const dir of DIR_NAMES) {
      const plDir = PIXELLAB_DIR_MAP[dir];
      const path = `${basePath}/rotations/${plDir}.png`;
      idlePromises.push(
        loadImg(path).then(img => { idleSprites[dir] = img; })
      );
    }
    await Promise.all(idlePromises);

    return { walk: sprites, idle: idleSprites };
  }

  // Load a Wang tileset from PixelLab-generated PNG + metadata JSON
  // Returns an array of 16 tile canvases indexed by Wang number (NW*8+NE*4+SW*2+SE)
  // Darken a canvas by overlaying semi-transparent black (source-atop preserves transparency)
  static darkenCanvas(canvas, amount = 0.2) {
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = `rgba(0, 0, 0, ${amount})`;
    ctx.globalCompositeOperation = 'source-atop';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.globalCompositeOperation = 'source-over';
    return canvas;
  }

  static async loadWangTileset(pngPath, metaPath) {
    // Load image
    const img = await new Promise((resolve, reject) => {
      const i = new Image();
      i.onload = () => resolve(i);
      i.onerror = () => reject(new Error('Failed to load tileset: ' + pngPath));
      i.src = pngPath;
    });

    // Load metadata
    const resp = await fetch(metaPath);
    const meta = await resp.json();

    // Parse tiles and index by Wang number
    const wangTiles = new Array(16).fill(null);
    for (const tile of meta.tileset_data.tiles) {
      const c = tile.corners;
      const nw = c.NW === 'upper' ? 1 : 0;
      const ne = c.NE === 'upper' ? 1 : 0;
      const sw = c.SW === 'upper' ? 1 : 0;
      const se = c.SE === 'upper' ? 1 : 0;
      const wangIdx = nw * 8 + ne * 4 + sw * 2 + se;

      // Extract tile from spritesheet
      const bb = tile.bounding_box;
      const canvas = document.createElement('canvas');
      canvas.width = bb.width;
      canvas.height = bb.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, bb.x, bb.y, bb.width, bb.height, 0, 0, bb.width, bb.height);
      wangTiles[wangIdx] = canvas;
    }
    return wangTiles;
  }

  // Generate tile sprites
  static generateTiles() {
    const tiles = {};
    const S = TILE_SIZE;

    // Grass tile (several variants)
    for (let v = 0; v < 4; v++) {
      const { canvas, ctx } = this.createCanvas(S, S);
      const base = ['#3a7a3a','#2d6b2d','#358035','#2f722f'][v];
      ctx.fillStyle = base;
      ctx.fillRect(0, 0, S, S);
      // Random grass details
      const rng = this.seededRandom(v * 1000);
      for (let i = 0; i < 8; i++) {
        const gx = Math.floor(rng() * S);
        const gy = Math.floor(rng() * S);
        ctx.fillStyle = rng() > 0.5 ? '#4a8a4a' : '#2a6a2a';
        ctx.fillRect(gx, gy, 2, 2);
      }
      tiles[`grass${v}`] = canvas;
    }

    // Path tile
    for (let v = 0; v < 2; v++) {
      const { canvas, ctx } = this.createCanvas(S, S);
      ctx.fillStyle = v === 0 ? '#a89060' : '#9a8555';
      ctx.fillRect(0, 0, S, S);
      const rng = this.seededRandom(v * 2000);
      for (let i = 0; i < 6; i++) {
        ctx.fillStyle = rng() > 0.5 ? '#b8a070' : '#908050';
        ctx.fillRect(Math.floor(rng()*S), Math.floor(rng()*S), 3, 2);
      }
      tiles[`path${v}`] = canvas;
    }

    // Water tile
    const { canvas: waterC, ctx: waterCtx } = this.createCanvas(S, S);
    waterCtx.fillStyle = '#2050a0';
    waterCtx.fillRect(0, 0, S, S);
    for (let i = 0; i < 4; i++) {
      waterCtx.fillStyle = '#3060b0';
      waterCtx.fillRect(i*8, 4 + (i%2)*4, 6, 2);
    }
    tiles.water = waterC;

    // Dark grass / forest floor
    const { canvas: darkG, ctx: darkGCtx } = this.createCanvas(S, S);
    darkGCtx.fillStyle = '#1a4a1a';
    darkGCtx.fillRect(0, 0, S, S);
    for (let i = 0; i < 6; i++) {
      darkGCtx.fillStyle = i%2===0 ? '#0d3d0d' : '#225522';
      darkGCtx.fillRect(Math.floor(Math.random()*S), Math.floor(Math.random()*S), 3, 2);
    }
    tiles.darkGrass = darkG;

    // Stone tile
    const { canvas: stoneC, ctx: stoneCtx } = this.createCanvas(S, S);
    stoneCtx.fillStyle = '#606070';
    stoneCtx.fillRect(0, 0, S, S);
    stoneCtx.fillStyle = '#50505f';
    stoneCtx.fillRect(0, 0, 15, 15);
    stoneCtx.fillRect(17, 17, 15, 15);
    stoneCtx.fillStyle = '#707080';
    stoneCtx.fillRect(17, 0, 15, 15);
    stoneCtx.fillRect(0, 17, 15, 15);
    stoneCtx.fillStyle = '#555565';
    stoneCtx.fillRect(0, 16, 32, 1);
    stoneCtx.fillRect(16, 0, 1, 32);
    tiles.stone = stoneC;

    // Volcanic / dragon lair tile
    const { canvas: volc, ctx: volcCtx } = this.createCanvas(S, S);
    volcCtx.fillStyle = '#2a1515';
    volcCtx.fillRect(0, 0, S, S);
    for (let i = 0; i < 5; i++) {
      volcCtx.fillStyle = ['#3a1a1a','#4a2020','#1a0a0a'][i%3];
      volcCtx.fillRect(Math.floor(Math.random()*S), Math.floor(Math.random()*S), 4, 3);
    }
    tiles.volcanic = volc;

    return tiles;
  }

  // Decorative sprites
  static generateDecorations() {
    const decos = {};
    const S = TILE_SIZE;

    // Tree (pine) — wider, more substantial
    const drawTree = (variant) => {
      const { canvas, ctx } = this.createCanvas(S, S*2);
      const trunk = variant === 0 ? '#5a3a20' : '#4a3018';
      const trunkDk = variant === 0 ? '#3a2a15' : '#342010';
      const leaves = variant === 0 ? '#1a5a1a' : '#0d4d0d';
      const leavesDk = variant === 0 ? '#104010' : '#083808';
      const leavesLt = variant === 0 ? '#2a7a2a' : '#1a6a1a';
      // Shadow on ground
      ctx.fillStyle = 'rgba(0,0,0,0.15)';
      ctx.fillRect(6, S+18, 20, 6);
      // Trunk
      ctx.fillStyle = trunk;
      ctx.fillRect(13, S, 6, S-4);
      ctx.fillStyle = trunkDk;
      ctx.fillRect(13, S, 2, S-4);
      // Foliage layers (wider triangular shape)
      const layerData = [
        { y: 4, w: 26 },
        { y: 12, w: 22 },
        { y: 20, w: 18 },
        { y: 28, w: 14 },
      ];
      for (const layer of layerData) {
        const x = (S - layer.w) / 2;
        ctx.fillStyle = leavesDk;
        ctx.fillRect(x, layer.y, layer.w, 12);
        ctx.fillStyle = leaves;
        ctx.fillRect(x+1, layer.y, layer.w-2, 10);
        ctx.fillStyle = leavesLt;
        ctx.fillRect(x+3, layer.y+1, layer.w-6, 4);
      }
      // Top point
      ctx.fillStyle = leavesLt;
      ctx.fillRect(14, 1, 4, 5);
      ctx.fillRect(15, 0, 2, 3);
      return canvas;
    };
    decos.tree0 = drawTree(0);
    decos.tree1 = drawTree(1);

    // Dead tree
    const { canvas: deadTree, ctx: dtCtx } = this.createCanvas(S, S*2);
    dtCtx.fillStyle = '#3a2a1a';
    dtCtx.fillRect(14, 10, 4, S+14);
    dtCtx.fillRect(10, 14, 4, 3);
    dtCtx.fillRect(18, 8, 6, 3);
    dtCtx.fillRect(8, 20, 3, 3);
    dtCtx.fillRect(20, 16, 4, 3);
    decos.deadTree = deadTree;

    // Castle tower
    const { canvas: towerC, ctx: tCtx } = this.createCanvas(S*2, S*2);
    // Base
    tCtx.fillStyle = '#808090';
    tCtx.fillRect(8, 20, 48, 44);
    tCtx.fillStyle = '#707080';
    tCtx.fillRect(12, 24, 40, 36);
    // Battlements
    tCtx.fillStyle = '#909098';
    for (let i = 0; i < 6; i++) {
      tCtx.fillRect(8 + i*9, 14, 6, 8);
    }
    // Door
    tCtx.fillStyle = '#4a3020';
    tCtx.fillRect(24, 44, 16, 20);
    tCtx.fillStyle = '#3a2010';
    tCtx.fillRect(26, 46, 12, 18);
    // Window
    tCtx.fillStyle = '#f0d060';
    tCtx.fillRect(22, 30, 6, 6);
    tCtx.fillRect(36, 30, 6, 6);
    // Flag
    tCtx.fillStyle = '#333';
    tCtx.fillRect(30, 2, 2, 14);
    tCtx.fillStyle = '#f0c040';
    tCtx.fillRect(32, 2, 10, 7);
    tCtx.fillStyle = '#d0a030';
    tCtx.fillRect(32, 5, 10, 4);
    decos.tower = towerC;

    // Treasure chest (power-up)
    const { canvas: chestC, ctx: cCtx } = this.createCanvas(S, S);
    cCtx.fillStyle = '#8a6020';
    cCtx.fillRect(6, 12, 20, 14);
    cCtx.fillStyle = '#a07030';
    cCtx.fillRect(8, 8, 16, 6);
    cCtx.fillStyle = '#f0c040';
    cCtx.fillRect(10, 10, 12, 2);
    cCtx.fillStyle = '#f0c040';
    cCtx.fillRect(14, 16, 4, 4);
    // Glow
    cCtx.fillStyle = 'rgba(240,192,64,0.3)';
    cCtx.fillRect(4, 6, 24, 22);
    decos.chest = chestC;

    // Flag / milestone marker
    const { canvas: flagC, ctx: fCtx } = this.createCanvas(S, S*2);
    fCtx.fillStyle = '#555';
    fCtx.fillRect(14, 8, 3, S+16);
    fCtx.fillStyle = '#f0c040';
    fCtx.fillRect(17, 8, 16, 10);
    fCtx.fillStyle = '#d0a030';
    fCtx.fillRect(17, 12, 16, 6);
    // Pennant cut
    fCtx.clearRect(30, 10, 4, 6);
    decos.flag = flagC;

    // Bow (on a stone pedestal, waiting to be picked up)
    const { canvas: bowC, ctx: bwCtx } = this.createCanvas(S, S*2);
    // Stone pedestal base — carved stone
    bwCtx.fillStyle = '#606060';
    bwCtx.fillRect(5, S+12, 22, 8);
    bwCtx.fillStyle = '#787878';
    bwCtx.fillRect(7, S+8, 18, 8);
    bwCtx.fillStyle = '#8a8a8a';
    bwCtx.fillRect(9, S+6, 14, 4);
    bwCtx.fillStyle = '#555';
    bwCtx.fillRect(7, S+14, 18, 2);
    // Pedestal highlight
    bwCtx.fillStyle = '#9a9a9a';
    bwCtx.fillRect(10, S+7, 12, 1);

    // Bow body — detailed recurve
    // Dark outline layer
    bwCtx.fillStyle = '#3a2010';
    bwCtx.fillRect(9, 2, 4, 2);
    bwCtx.fillRect(7, 4, 4, 3);
    bwCtx.fillRect(6, 7, 3, 4);
    bwCtx.fillRect(5, 11, 3, 6);
    bwCtx.fillRect(6, 17, 3, 4);
    bwCtx.fillRect(7, 21, 4, 3);
    bwCtx.fillRect(9, 24, 4, 3);
    bwCtx.fillRect(11, 27, 4, 2);

    // Main wood — warm brown
    bwCtx.fillStyle = '#9a5828';
    bwCtx.fillRect(10, 3, 2, 2);     // top recurve
    bwCtx.fillRect(8, 5, 2, 3);
    bwCtx.fillRect(7, 8, 2, 3);
    bwCtx.fillRect(6, 11, 2, 6);     // widest point
    bwCtx.fillRect(7, 17, 2, 4);
    bwCtx.fillRect(8, 21, 2, 3);
    bwCtx.fillRect(10, 24, 2, 3);
    bwCtx.fillRect(12, 27, 2, 2);    // bottom recurve

    // Wood highlight — lighter inner edge
    bwCtx.fillStyle = '#b87838';
    bwCtx.fillRect(10, 4, 1, 1);
    bwCtx.fillRect(8, 6, 1, 2);
    bwCtx.fillRect(7, 9, 1, 2);
    bwCtx.fillRect(6, 13, 1, 2);
    bwCtx.fillRect(7, 18, 1, 2);
    bwCtx.fillRect(9, 22, 1, 2);
    bwCtx.fillRect(11, 25, 1, 2);

    // Grip wrap — golden leather with bands
    bwCtx.fillStyle = '#d4a830';
    bwCtx.fillRect(5, 13, 3, 6);
    bwCtx.fillStyle = '#e8c040';
    bwCtx.fillRect(6, 14, 1, 4);
    // Grip detail lines
    bwCtx.fillStyle = '#b08820';
    bwCtx.fillRect(5, 14, 3, 1);
    bwCtx.fillRect(5, 16, 3, 1);

    // Nock tips — polished metal
    bwCtx.fillStyle = '#c8c8c8';
    bwCtx.fillRect(10, 2, 2, 1);
    bwCtx.fillRect(12, 28, 2, 1);
    bwCtx.fillStyle = '#e0e0e0';
    bwCtx.fillRect(11, 2, 1, 1);
    bwCtx.fillRect(13, 28, 1, 1);

    // Bowstring — thin taut line connecting nock tips
    bwCtx.fillStyle = '#e0d8c0';
    bwCtx.fillRect(13, 3, 1, 4);
    bwCtx.fillRect(13, 7, 1, 4);
    bwCtx.fillRect(13, 11, 1, 4);
    bwCtx.fillRect(13, 15, 1, 4);
    bwCtx.fillRect(13, 19, 1, 4);
    bwCtx.fillRect(13, 23, 1, 5);
    // String highlights
    bwCtx.fillStyle = '#f0ece0';
    bwCtx.fillRect(13, 13, 1, 1);
    bwCtx.fillRect(13, 17, 1, 1);

    // Arrow resting on bow
    bwCtx.fillStyle = '#b08040';
    bwCtx.fillRect(13, 15, 14, 2);
    // Arrow shaft grain
    bwCtx.fillStyle = '#c09050';
    bwCtx.fillRect(15, 15, 2, 1);
    bwCtx.fillRect(20, 15, 2, 1);
    // Arrow tip — iron
    bwCtx.fillStyle = '#707070';
    bwCtx.fillRect(25, 14, 3, 4);
    bwCtx.fillStyle = '#909090';
    bwCtx.fillRect(26, 15, 2, 2);
    bwCtx.fillStyle = '#b0b0b0';
    bwCtx.fillRect(27, 15, 1, 1);
    // Arrow fletching — red feathers
    bwCtx.fillStyle = '#cc3030';
    bwCtx.fillRect(13, 13, 3, 2);
    bwCtx.fillRect(13, 17, 3, 2);
    bwCtx.fillStyle = '#e04040';
    bwCtx.fillRect(14, 13, 1, 1);
    bwCtx.fillRect(14, 17, 1, 1);

    decos.bow = bowC;

    // Dragon
    const { canvas: dragonC, ctx: dCtx } = this.createCanvas(S*3, S*3);
    const dragonRed = '#c03030';
    const dragonDk = '#901818';
    const dragonLt = '#e04040';
    const belly = '#d0a040';
    // Body
    dCtx.fillStyle = dragonRed;
    dCtx.fillRect(24, 40, 48, 30);
    dCtx.fillStyle = dragonDk;
    dCtx.fillRect(28, 44, 40, 22);
    dCtx.fillStyle = belly;
    dCtx.fillRect(34, 48, 28, 14);
    // Head
    dCtx.fillStyle = dragonRed;
    dCtx.fillRect(60, 24, 24, 20);
    dCtx.fillStyle = dragonLt;
    dCtx.fillRect(64, 28, 16, 12);
    // Eye
    dCtx.fillStyle = '#ff0';
    dCtx.fillRect(74, 30, 6, 4);
    dCtx.fillStyle = '#000';
    dCtx.fillRect(76, 31, 3, 2);
    // Horns
    dCtx.fillStyle = '#555';
    dCtx.fillRect(66, 18, 4, 8);
    dCtx.fillRect(76, 20, 4, 6);
    // Wings
    dCtx.fillStyle = dragonDk;
    dCtx.fillRect(10, 20, 30, 24);
    dCtx.fillStyle = dragonRed;
    dCtx.fillRect(14, 24, 22, 16);
    // Wing membrane lines
    dCtx.fillStyle = dragonLt;
    dCtx.fillRect(16, 26, 2, 12);
    dCtx.fillRect(22, 24, 2, 14);
    dCtx.fillRect(28, 26, 2, 12);
    // Tail
    dCtx.fillStyle = dragonDk;
    dCtx.fillRect(8, 56, 20, 8);
    dCtx.fillRect(2, 52, 10, 8);
    dCtx.fillStyle = dragonRed;
    dCtx.fillRect(0, 50, 6, 6);
    // Legs
    dCtx.fillStyle = dragonDk;
    dCtx.fillRect(32, 68, 8, 14);
    dCtx.fillRect(54, 68, 8, 14);
    dCtx.fillRect(30, 78, 12, 6);
    dCtx.fillRect(52, 78, 12, 6);
    // Claws
    dCtx.fillStyle = '#555';
    dCtx.fillRect(30, 82, 4, 3);
    dCtx.fillRect(36, 82, 4, 3);
    dCtx.fillRect(52, 82, 4, 3);
    dCtx.fillRect(58, 82, 4, 3);
    // Mouth / fire hint
    dCtx.fillStyle = '#f08020';
    dCtx.fillRect(82, 34, 8, 4);
    dCtx.fillStyle = '#f0c040';
    dCtx.fillRect(88, 35, 4, 2);
    decos.dragon = dragonC;

    // Rocks — small pile of 3 stones with highlights and shadows
    const { canvas: rockC, ctx: rCtx } = this.createCanvas(S, S);
    // Large stone (back)
    rCtx.fillStyle = '#5a5a5a';
    rCtx.fillRect(6, 18, 14, 10);
    rCtx.fillStyle = '#6e6e6e';
    rCtx.fillRect(8, 16, 10, 10);
    rCtx.fillStyle = '#7e7e7e'; // highlight
    rCtx.fillRect(9, 17, 6, 4);
    rCtx.fillStyle = '#4a4a4a'; // shadow
    rCtx.fillRect(8, 24, 10, 3);
    // Medium stone (right)
    rCtx.fillStyle = '#626262';
    rCtx.fillRect(18, 20, 10, 8);
    rCtx.fillStyle = '#747474';
    rCtx.fillRect(19, 19, 8, 7);
    rCtx.fillStyle = '#848484'; // highlight
    rCtx.fillRect(20, 20, 4, 3);
    // Small stone (front-left)
    rCtx.fillStyle = '#6a6a6a';
    rCtx.fillRect(4, 24, 8, 6);
    rCtx.fillStyle = '#7a7a7a';
    rCtx.fillRect(5, 23, 6, 5);
    // Moss patches
    rCtx.fillStyle = '#4a6a3a';
    rCtx.fillRect(10, 18, 3, 2);
    rCtx.fillRect(21, 21, 2, 2);
    decos.rock = rockC;

    // Boulder — larger single rock with detailed shading
    const { canvas: boulderC, ctx: boCtx } = this.createCanvas(S, S);
    // Main body
    boCtx.fillStyle = '#585858';
    boCtx.fillRect(4, 12, 24, 18);
    boCtx.fillStyle = '#686868';
    boCtx.fillRect(6, 10, 20, 18);
    boCtx.fillStyle = '#7a7a7a';
    boCtx.fillRect(8, 8, 16, 16);
    // Top highlight
    boCtx.fillStyle = '#909090';
    boCtx.fillRect(10, 10, 10, 6);
    boCtx.fillStyle = '#9a9a9a';
    boCtx.fillRect(12, 11, 6, 3);
    // Bottom shadow
    boCtx.fillStyle = '#484848';
    boCtx.fillRect(6, 26, 20, 4);
    boCtx.fillStyle = '#404040';
    boCtx.fillRect(8, 28, 16, 2);
    // Cracks
    boCtx.fillStyle = '#505050';
    boCtx.fillRect(14, 14, 2, 8);
    boCtx.fillRect(10, 18, 6, 2);
    // Moss
    boCtx.fillStyle = '#4a6a3a';
    boCtx.fillRect(8, 22, 4, 3);
    boCtx.fillRect(18, 24, 3, 2);
    boCtx.fillStyle = '#5a7a4a';
    boCtx.fillRect(9, 23, 2, 2);
    decos.boulder = boulderC;

    // Flowers — cluster of colorful wildflowers with stems
    const { canvas: flowerC, ctx: flCtx } = this.createCanvas(S, S);
    // Stems
    flCtx.fillStyle = '#3a7a3a';
    flCtx.fillRect(10, 20, 2, 8);
    flCtx.fillRect(16, 18, 2, 10);
    flCtx.fillRect(22, 22, 2, 6);
    flCtx.fillStyle = '#4a8a4a';
    flCtx.fillRect(13, 22, 2, 6);
    flCtx.fillRect(19, 20, 2, 8);
    // Leaves
    flCtx.fillStyle = '#3a8a3a';
    flCtx.fillRect(8, 24, 4, 2);
    flCtx.fillRect(18, 26, 4, 2);
    flCtx.fillRect(14, 25, 3, 2);
    // Pink flower (left)
    flCtx.fillStyle = '#d04070';
    flCtx.fillRect(8, 16, 6, 6);
    flCtx.fillStyle = '#e06090';
    flCtx.fillRect(9, 17, 4, 4);
    flCtx.fillStyle = '#ffcc44';
    flCtx.fillRect(10, 18, 2, 2);
    // Yellow flower (center)
    flCtx.fillStyle = '#d0a020';
    flCtx.fillRect(14, 14, 6, 6);
    flCtx.fillStyle = '#e8c040';
    flCtx.fillRect(15, 15, 4, 4);
    flCtx.fillStyle = '#a06010';
    flCtx.fillRect(16, 16, 2, 2);
    // White/blue flower (right)
    flCtx.fillStyle = '#7090d0';
    flCtx.fillRect(20, 18, 6, 6);
    flCtx.fillStyle = '#90b0e0';
    flCtx.fillRect(21, 19, 4, 4);
    flCtx.fillStyle = '#ffdd55';
    flCtx.fillRect(22, 20, 2, 2);
    decos.flower = flowerC;

    // Rose bush — red roses on a green bush
    const { canvas: roseBushC, ctx: rbCtx } = this.createCanvas(S, S);
    // Bush body
    rbCtx.fillStyle = '#2a5a2a';
    rbCtx.fillRect(4, 14, 24, 16);
    rbCtx.fillStyle = '#3a6a3a';
    rbCtx.fillRect(6, 12, 20, 16);
    rbCtx.fillStyle = '#4a7a4a';
    rbCtx.fillRect(8, 10, 16, 14);
    // Leaf highlights
    rbCtx.fillStyle = '#5a8a4a';
    rbCtx.fillRect(10, 12, 4, 3);
    rbCtx.fillRect(18, 14, 3, 3);
    rbCtx.fillRect(12, 20, 4, 2);
    // Red roses (3 roses)
    rbCtx.fillStyle = '#c02020';
    rbCtx.fillRect(8, 12, 6, 5);
    rbCtx.fillStyle = '#e03030';
    rbCtx.fillRect(9, 13, 4, 3);
    rbCtx.fillStyle = '#c02020';
    rbCtx.fillRect(18, 10, 5, 5);
    rbCtx.fillStyle = '#e03030';
    rbCtx.fillRect(19, 11, 3, 3);
    rbCtx.fillStyle = '#c02020';
    rbCtx.fillRect(12, 18, 6, 5);
    rbCtx.fillStyle = '#e03030';
    rbCtx.fillRect(13, 19, 4, 3);
    // Rose centers
    rbCtx.fillStyle = '#ff5555';
    rbCtx.fillRect(10, 14, 2, 1);
    rbCtx.fillRect(20, 12, 1, 1);
    rbCtx.fillRect(14, 20, 2, 1);
    decos.roseBush = roseBushC;

    // Bridge section
    const { canvas: bridgeC, ctx: brCtx } = this.createCanvas(S, S);
    brCtx.fillStyle = '#6a4a30';
    brCtx.fillRect(0, 8, S, 16);
    brCtx.fillStyle = '#7a5a40';
    for (let i = 0; i < 4; i++) {
      brCtx.fillRect(i*8, 10, 6, 12);
    }
    brCtx.fillStyle = '#5a3a20';
    brCtx.fillRect(0, 8, S, 2);
    brCtx.fillRect(0, 22, S, 2);
    decos.bridge = bridgeC;

    // Campfire
    const { canvas: fireC, ctx: fiCtx } = this.createCanvas(S, S);
    fiCtx.fillStyle = '#5a3a20';
    fiCtx.fillRect(8, 22, 16, 6);
    fiCtx.fillStyle = '#f08020';
    fiCtx.fillRect(12, 12, 8, 12);
    fiCtx.fillStyle = '#f0c040';
    fiCtx.fillRect(14, 8, 4, 10);
    fiCtx.fillStyle = '#fff0a0';
    fiCtx.fillRect(15, 10, 2, 4);
    decos.campfire = fireC;

    // Signpost
    const { canvas: signC, ctx: siCtx } = this.createCanvas(S, S*2);
    siCtx.fillStyle = '#5a3a20';
    siCtx.fillRect(14, 16, 4, 32);
    siCtx.fillStyle = '#7a5a40';
    siCtx.fillRect(4, 16, 24, 10);
    siCtx.fillStyle = '#6a4a30';
    siCtx.fillRect(6, 18, 20, 6);
    decos.signpost = signC;

    // Skull (for dragon lair area)
    const { canvas: skullC, ctx: skCtx } = this.createCanvas(S, S);
    skCtx.fillStyle = '#d0d0c0';
    skCtx.fillRect(10, 14, 12, 10);
    skCtx.fillRect(12, 12, 8, 4);
    skCtx.fillStyle = '#222';
    skCtx.fillRect(12, 16, 3, 3);
    skCtx.fillRect(17, 16, 3, 3);
    skCtx.fillRect(14, 22, 4, 2);
    decos.skull = skullC;

    // Lava pool
    const { canvas: lavaC, ctx: laCtx } = this.createCanvas(S, S);
    laCtx.fillStyle = '#c03010';
    laCtx.fillRect(4, 8, 24, 16);
    laCtx.fillStyle = '#e06020';
    laCtx.fillRect(8, 10, 16, 12);
    laCtx.fillStyle = '#f0a040';
    laCtx.fillRect(12, 12, 8, 8);
    laCtx.fillStyle = '#ffe080';
    laCtx.fillRect(14, 14, 4, 4);
    decos.lava = lavaC;

    // Checkmark for completed items
    const { canvas: checkC, ctx: chkCtx } = this.createCanvas(16, 16);
    chkCtx.fillStyle = '#40e040';
    chkCtx.fillRect(2, 8, 3, 3);
    chkCtx.fillRect(4, 10, 3, 3);
    chkCtx.fillRect(6, 8, 3, 3);
    chkCtx.fillRect(8, 6, 3, 3);
    chkCtx.fillRect(10, 4, 3, 3);
    chkCtx.fillRect(12, 2, 3, 3);
    decos.checkmark = checkC;

    return decos;
  }

  static seededRandom(seed) {
    let s = seed;
    return () => {
      s = (s * 16807 + 0) % 2147483647;
      return (s - 1) / 2147483646;
    };
  }
}

// ============================================================
// MAP GENERATOR
// ============================================================
class WorldMap {
  constructor() {
    this.cols = MAP_COLS;
    this.rows = MAP_ROWS;
    this.grid = [];
    this.decorations = [];
    this.generate();
  }

  generate() {
    // Initialize with grass
    for (let y = 0; y < this.rows; y++) {
      this.grid[y] = [];
      for (let x = 0; x < this.cols; x++) {
        this.grid[y][x] = 'grass';
      }
    }

    // Winding right-angle path through all roadmap items
    // We draw L-shaped segments between consecutive items
    const waypoints = [
      { x: 4, y: 10 },   // start
      { x: 16, y: 10 },  // item 1 — East
      { x: 30, y: 10 },  // item 2 — East
      { x: 30, y: 24 },  // item 3 — South (turn!)
      { x: 44, y: 24 },  // milestone1 — East
      { x: 44, y: 12 },  // item 4 — North (turn!)
      { x: 58, y: 12 },  // item 5 — East
      { x: 58, y: 38 },  // item 6 — South (turn!) — pushed down for clear gap from stop 4
      { x: 44, y: 38 },  // item 7 — West (turn!)
      { x: 44, y: 52 },  // dragon — South (turn!)
    ];

    // Draw right-angle path segments
    for (let i = 0; i < waypoints.length - 1; i++) {
      this.drawStraightPath(waypoints[i], waypoints[i + 1]);
    }

    // Terrain zones ------------------------------------------------
    // Use noise-based boundaries for organic, irregular shapes

    const zoneRng = PixelArt.seededRandom(777);
    // Pre-compute noise offsets for organic boundaries
    const noiseTable = [];
    for (let i = 0; i < 200; i++) noiseTable.push(zoneRng() * 6 - 3); // -3 to +3 tile variance

    const zoneNoise = (idx) => noiseTable[Math.abs(idx) % noiseTable.length];

    // Forest zone — covers entire left side of map with organic right edge
    // The dark forest runs the full height of the map on the left
    for (let y = 0; y < this.rows; y++) {
      // Right edge varies by vertical position — wider at top, narrows in middle, widens again at bottom
      let forestRightEdge;
      if (y < 8) {
        forestRightEdge = 16 + zoneNoise(y * 3);        // Wide top
      } else if (y < 22) {
        forestRightEdge = 12 + zoneNoise(y * 3);        // Start area
      } else if (y < 35) {
        forestRightEdge = 10 + zoneNoise(y * 3 + 50);   // Mid section
      } else {
        forestRightEdge = 14 + zoneNoise(y * 3 + 80);   // Lower section wider
      }
      for (let x = 0; x < Math.min(Math.floor(forestRightEdge), this.cols); x++) {
        if (this.grid[y][x] === 'grass') {
          this.grid[y][x] = 'darkGrass';
        }
      }
    }

    // Top strip always dark — full width fading out
    for (let y = 0; y < 4; y++) {
      for (let x = 0; x < 20 + zoneNoise(y + 200); x++) {
        if (x < this.cols && this.grid[y][x] === 'grass') this.grid[y][x] = 'darkGrass';
      }
    }

    // Water features — positioned well within terrain zones
    this.addWaterBody(5, 14, 6, 4, 101);    // Inside dark forest zone
    this.addWaterBody(22, 2, 5, 4, 202);    // Upper grass zone
    this.addWaterBody(50, 20, 6, 4, 303);   // Grass zone south
    this.addWaterBody(36, 42, 5, 4, 404);   // Before volcanic
    this.addWaterBody(8, 50, 6, 4, 505);    // Lower area

    // Stone / castle area near milestone1 — organic edges
    for (let y = 18; y < 30; y++) {
      for (let x = 36; x < 52; x++) {
        const edgeDistX = Math.min(x - 36, 52 - x);
        const edgeDistY = Math.min(y - 18, 30 - y);
        const edgeDist = Math.min(edgeDistX, edgeDistY);
        if (edgeDist > 1 + zoneNoise(x + y * 7) * 0.5 && this.grid[y][x] === 'grass') {
          this.grid[y][x] = 'stone';
        }
      }
    }

    // Second stone area near power-ups north section — organic edges
    for (let y = 6; y < 18; y++) {
      for (let x = 38; x < 50; x++) {
        const edgeDistX = Math.min(x - 38, 50 - x);
        const edgeDistY = Math.min(y - 6, 18 - y);
        const edgeDist = Math.min(edgeDistX, edgeDistY);
        if (edgeDist > 1 + zoneNoise(x * 3 + y * 5) * 0.4 && this.grid[y][x] === 'grass') {
          this.grid[y][x] = 'stone';
        }
      }
    }

    // Volcanic area near dragon — organic edges spreading from center (44,52)
    for (let y = 42; y < this.rows; y++) {
      for (let x = 30; x < 60; x++) {
        const dist = Math.sqrt((x - 44) ** 2 + (y - 52) ** 2);
        const noiseOff = zoneNoise(x * 2 + y * 3 + 400);
        const maxRadius = y >= 48 ? 18 : 10;
        if (dist < maxRadius + noiseOff && this.grid[y][x] !== 'path') {
          this.grid[y][x] = 'volcanic';
        }
      }
    }
    // Bottom rows always volcanic
    for (let y = this.rows - 4; y < this.rows; y++) {
      for (let x = 0; x < this.cols; x++) {
        if (this.grid[y][x] !== 'path') this.grid[y][x] = 'volcanic';
      }
    }

    // Dark forest patches for variety — organic edges
    for (let y = 24; y < 46; y++) {
      const leftEdge = 60 + zoneNoise(y * 4 + 500);
      for (let x = Math.max(0, Math.floor(leftEdge)); x < this.cols; x++) {
        if (this.grid[y][x] === 'grass') this.grid[y][x] = 'darkGrass';
      }
    }
    for (let y = 0; y < 10; y++) {
      const leftEdge = 58 + zoneNoise(y * 4 + 600);
      for (let x = Math.max(0, Math.floor(leftEdge)); x < this.cols; x++) {
        if (this.grid[y][x] === 'grass') this.grid[y][x] = 'darkGrass';
      }
    }
    // Top-right corner dark
    for (let y = 0; y < 6 + zoneNoise(700); y++) {
      for (let x = this.cols - 8; x < this.cols; x++) {
        if (this.grid[y][x] === 'grass') this.grid[y][x] = 'darkGrass';
      }
    }
    // Bottom rows — dark forest for anything not already volcanic or path
    for (let y = this.rows - 10; y < this.rows; y++) {
      for (let x = 0; x < 18 + zoneNoise(y + 800); x++) {
        if (x >= 0 && x < this.cols && this.grid[y][x] === 'grass') {
          this.grid[y][x] = 'darkGrass';
        }
      }
    }
    // Right edge dark forest
    for (let y = 0; y < this.rows; y++) {
      for (let x = this.cols - 4; x < this.cols; x++) {
        if (this.grid[y][x] === 'grass') this.grid[y][x] = 'darkGrass';
      }
    }

    // Add decorations
    this.addDecorations();
  }

  drawStraightPath(from, to) {
    // Draw a straight horizontal or vertical path (right-angle segments)
    const dx = to.x - from.x;
    const dy = to.y - from.y;

    // Determine if we go horizontal first, then vertical
    // For this layout, just draw straight since waypoints are axis-aligned
    if (dx !== 0 && dy !== 0) {
      // L-shaped: go horizontal first, then vertical
      const mid = { x: to.x, y: from.y };
      this.drawStraightPath(from, mid);
      this.drawStraightPath(mid, to);
      return;
    }

    const steps = Math.max(Math.abs(dx), Math.abs(dy));
    for (let i = 0; i <= steps; i++) {
      const px = Math.round(from.x + (dx * i / steps));
      const py = Math.round(from.y + (dy * i / steps));
      // Make path 5 tiles wide for smoother transitions
      for (let oy = -2; oy <= 2; oy++) {
        for (let ox = -2; ox <= 2; ox++) {
          const nx = px + ox, ny = py + oy;
          if (nx >= 0 && nx < this.cols && ny >= 0 && ny < this.rows) {
            this.grid[ny][nx] = 'path';
          }
        }
      }
    }
  }

  addWaterBody(cx, cy, w, h, seed) {
    // Create a natural pond shape using overlapping blobs
    const rng = PixelArt.seededRandom(seed || (cx * 100 + cy));
    const centerX = cx + w / 2;
    const centerY = cy + h / 2;

    // Generate 3-5 overlapping ellipses for organic shape
    const blobCount = 3 + Math.floor(rng() * 3);
    const blobs = [];
    for (let i = 0; i < blobCount; i++) {
      blobs.push({
        x: centerX + (rng() - 0.5) * w * 0.6,
        y: centerY + (rng() - 0.5) * h * 0.6,
        rx: w * (0.3 + rng() * 0.3),
        ry: h * (0.3 + rng() * 0.3)
      });
    }

    // Check each tile against all blobs
    const margin = 3;
    for (let dy = -margin; dy <= h + margin; dy++) {
      for (let dx = -margin; dx <= w + margin; dx++) {
        const nx = cx + dx, ny = cy + dy;
        if (nx < 0 || nx >= this.cols || ny < 0 || ny >= this.rows) continue;
        if (this.grid[ny][nx] === 'path') continue;

        // Check if this tile is inside any blob
        let inside = false;
        for (const blob of blobs) {
          const bx = (nx - blob.x) / blob.rx;
          const by = (ny - blob.y) / blob.ry;
          if (bx * bx + by * by < 1.0) {
            inside = true;
            break;
          }
        }
        if (inside) {
          this.grid[ny][nx] = 'water';
        }
      }
    }
  }

  addDecorations() {
    const rng = PixelArt.seededRandom(42);

    const notTooClose = (x, y, minDist = 3) => {
      return !ROADMAP_ITEMS.some(item =>
        Math.abs(item.mapX - x) < minDist && Math.abs(item.mapY - y) < minDist
      );
    };

    const canPlace = (x, y, allowedTiles) => {
      if (!this.grid[y] || !this.grid[y][x]) return false;
      return allowedTiles.includes(this.grid[y][x]);
    };

    // Trees in dark forest areas (left start area)
    for (let i = 0; i < 30; i++) {
      const x = Math.floor(rng() * 12);
      const y = Math.floor(rng() * 20);
      if (canPlace(x, y, ['darkGrass']) && notTooClose(x, y)) {
        this.decorations.push({ type: rng() > 0.3 ? 'tree0' : 'tree1', x, y });
      }
    }

    // Trees scattered across the whole map on grass
    for (let i = 0; i < 80; i++) {
      const x = Math.floor(rng() * this.cols);
      const y = Math.floor(rng() * this.rows);
      if (canPlace(x, y, ['grass', 'darkGrass']) && notTooClose(x, y, 4)) {
        this.decorations.push({ type: rng() > 0.5 ? 'tree0' : 'tree1', x, y });
      }
    }

    // Dead trees in volcanic area
    for (let i = 0; i < 12; i++) {
      const x = 34 + Math.floor(rng() * 24);
      const y = 44 + Math.floor(rng() * 14);
      if (canPlace(x, y, ['volcanic']) && notTooClose(x, y)) {
        this.decorations.push({ type: 'deadTree', x, y });
      }
    }

    // Small rocks scattered
    for (let i = 0; i < 20; i++) {
      const x = Math.floor(rng() * this.cols);
      const y = Math.floor(rng() * this.rows);
      if (canPlace(x, y, ['grass', 'darkGrass', 'stone', 'volcanic']) && notTooClose(x, y)) {
        this.decorations.push({ type: 'rock', x, y });
      }
    }

    // Boulders — larger, less frequent, on stone and volcanic
    for (let i = 0; i < 12; i++) {
      const x = Math.floor(rng() * this.cols);
      const y = Math.floor(rng() * this.rows);
      if (canPlace(x, y, ['stone', 'volcanic', 'darkGrass']) && notTooClose(x, y)) {
        this.decorations.push({ type: 'boulder', x, y });
      }
    }

    // Flowers scattered on grass
    for (let i = 0; i < 30; i++) {
      const x = Math.floor(rng() * this.cols);
      const y = Math.floor(rng() * this.rows);
      if (canPlace(x, y, ['grass', 'darkGrass'])) {
        this.decorations.push({ type: 'flower', x, y });
      }
    }

    // Rose bushes — along path edges and in grass areas
    for (let i = 0; i < 20; i++) {
      const x = Math.floor(rng() * this.cols);
      const y = Math.floor(rng() * this.rows);
      if (canPlace(x, y, ['grass']) && notTooClose(x, y, 2)) {
        this.decorations.push({ type: 'roseBush', x, y });
      }
    }

    // Skulls in volcanic area
    for (let i = 0; i < 8; i++) {
      const x = 36 + Math.floor(rng() * 20);
      const y = 40 + Math.floor(rng() * 16);
      if (canPlace(x, y, ['volcanic'])) {
        this.decorations.push({ type: 'skull', x, y });
      }
    }

    // Lava pools near dragon
    this.decorations.push({ type: 'lava', x: 40, y: 46 });
    this.decorations.push({ type: 'lava', x: 48, y: 48 });
    this.decorations.push({ type: 'lava', x: 42, y: 50 });
    this.decorations.push({ type: 'lava', x: 50, y: 42 });

    // Campfire at start
    this.decorations.push({ type: 'campfire', x: 6, y: 12 });

    // Signposts at turns
    this.decorations.push({ type: 'signpost', x: 8, y: 9 });
    this.decorations.push({ type: 'signpost', x: 31, y: 16 });
    this.decorations.push({ type: 'signpost', x: 45, y: 18 });
    this.decorations.push({ type: 'signpost', x: 52, y: 29 });

    // Sort decorations by Y for proper layering
    this.decorations.sort((a, b) => a.y - b.y);
  }

  isWalkable(x, y) {
    const col = Math.floor(x / TILE_SIZE);
    const row = Math.floor(y / TILE_SIZE);
    if (col < 0 || col >= this.cols || row < 0 || row >= this.rows) return false;
    return this.grid[row][col] === 'path';
  }
}

// ============================================================
// CHARACTER
// ============================================================
class Character {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.dir = 4; // facing south
    this.speed = 3.5;
    this.frame = 0;
    this.frameTimer = 0;
    this.moving = false;
    this.sprites = null;
    this.visitedItems = new Set();
    this.hasBow = false;
    this.jumpTimer = 0; // frames remaining in jump animation
  }

  loadSprites(spriteData) {
    // spriteData: { walk: {dir: [Image, ...]}, idle: {dir: Image} }
    this.walkSprites = spriteData.walk;
    this.idleSprites = spriteData.idle;
    this.sprites = spriteData.walk; // Keep for compatibility checks
  }

  update(keys, worldMap) {
    let dx = 0, dy = 0;

    if (keys.up) dy -= 1;
    if (keys.down) dy += 1;
    if (keys.left) dx -= 1;
    if (keys.right) dx += 1;

    this.moving = dx !== 0 || dy !== 0;

    if (this.moving) {
      // Determine direction
      if (dx === 0 && dy < 0) this.dir = 0;
      else if (dx > 0 && dy < 0) this.dir = 1;
      else if (dx > 0 && dy === 0) this.dir = 2;
      else if (dx > 0 && dy > 0) this.dir = 3;
      else if (dx === 0 && dy > 0) this.dir = 4;
      else if (dx < 0 && dy > 0) this.dir = 5;
      else if (dx < 0 && dy === 0) this.dir = 6;
      else if (dx < 0 && dy < 0) this.dir = 7;

      // Normalize diagonal speed
      const len = Math.sqrt(dx * dx + dy * dy);
      dx = (dx / len) * this.speed;
      dy = (dy / len) * this.speed;

      // Check collision
      const newX = this.x + dx;
      const newY = this.y + dy;

      // Check multiple points around character
      const halfW = 10, halfH = 6;
      const canMoveX = worldMap.isWalkable(newX - halfW, this.y - halfH)
        && worldMap.isWalkable(newX + halfW, this.y - halfH)
        && worldMap.isWalkable(newX - halfW, this.y + halfH)
        && worldMap.isWalkable(newX + halfW, this.y + halfH);

      const canMoveY = worldMap.isWalkable(this.x - halfW, newY - halfH)
        && worldMap.isWalkable(this.x + halfW, newY - halfH)
        && worldMap.isWalkable(this.x - halfW, newY + halfH)
        && worldMap.isWalkable(this.x + halfW, newY + halfH);

      if (canMoveX) this.x = newX;
      if (canMoveY) this.y = newY;

      // Clamp to map
      this.x = Math.max(12, Math.min(this.x, MAP_COLS * TILE_SIZE - 12));
      this.y = Math.max(12, Math.min(this.y, MAP_ROWS * TILE_SIZE - 12));

      // Animate
      this.frameTimer++;
      if (this.frameTimer > 8) {
        this.frameTimer = 0;
        this.frame = (this.frame + 1) % 6;
      }
    } else {
      this.frame = 0;
      this.frameTimer = 0;
    }

    // Tick jump animation
    if (this.jumpTimer > 0) this.jumpTimer--;
  }

  draw(ctx, cameraX, cameraY) {
    if (!this.sprites) return;
    const dirName = DIR_NAMES[this.dir];
    // Use walk animation when moving, idle rotation when standing
    let sprite;
    if (this.moving && this.walkSprites && this.walkSprites[dirName]) {
      sprite = this.walkSprites[dirName][this.frame];
    } else if (this.idleSprites && this.idleSprites[dirName]) {
      sprite = this.idleSprites[dirName];
    } else {
      sprite = this.walkSprites[dirName][0];
    }
    // Sprite is 48x48, center horizontally and anchor feet at character position
    // Jump arc: peak at midpoint of jumpTimer (12 frames total, peak at 6)
    const jumpOffset = this.jumpTimer > 0 ? Math.sin((this.jumpTimer / 12) * Math.PI) * 14 : 0;
    const drawX = this.x - cameraX - 24;
    const drawY = this.y - cameraY - 40 - jumpOffset;
    ctx.drawImage(sprite, drawX, drawY);

    // Draw held bow
    if (this.hasBow) {
      const d = this.dir;
      // Offset bow position based on facing direction (adjusted for 48px sprite)
      let ox, oy, flip;
      if (d === 2 || d === 1 || d === 3) {       // east-ish: bow on right side
        ox = 28; oy = 0; flip = false;
      } else if (d === 6 || d === 5 || d === 7) { // west-ish: bow on left side
        ox = -8; oy = 0; flip = true;
      } else if (d === 0) {                        // north: bow on right
        ox = 26; oy = 2; flip = false;
      } else {                                      // south: bow on left
        ox = -6; oy = 2; flip = true;
      }
      const bob = this.moving ? Math.sin(this.frameTimer * 0.6) * 1.5 : 0;
      const bx = drawX + ox;
      const by = drawY + oy + bob;

      ctx.save();
      if (flip) {
        ctx.translate(bx + 8, by);
        ctx.scale(-1, 1);
        ctx.translate(-(bx + 8), -by);
      }

      // -- Detailed recurve bow --
      // Dark outline/shadow first
      ctx.fillStyle = '#3a2010';
      // Top limb outline
      ctx.fillRect(bx + 3, by - 12, 3, 2);
      ctx.fillRect(bx + 4, by - 10, 3, 3);
      ctx.fillRect(bx + 5, by - 7, 3, 3);
      ctx.fillRect(bx + 6, by - 4, 3, 4);
      // Bottom limb outline
      ctx.fillRect(bx + 6, by + 6, 3, 4);
      ctx.fillRect(bx + 5, by + 10, 3, 3);
      ctx.fillRect(bx + 4, by + 13, 3, 3);
      ctx.fillRect(bx + 3, by + 16, 3, 2);

      // Main wood — warm brown
      ctx.fillStyle = '#9a5828';
      // Top recurve tip
      ctx.fillRect(bx + 4, by - 11, 2, 2);
      // Upper limb (curves outward)
      ctx.fillRect(bx + 5, by - 9, 2, 3);
      ctx.fillRect(bx + 6, by - 6, 2, 3);
      ctx.fillRect(bx + 7, by - 3, 2, 4);
      // Lower limb (curves outward)
      ctx.fillRect(bx + 7, by + 5, 2, 4);
      ctx.fillRect(bx + 6, by + 9, 2, 3);
      ctx.fillRect(bx + 5, by + 12, 2, 3);
      // Bottom recurve tip
      ctx.fillRect(bx + 4, by + 15, 2, 2);

      // Lighter inner highlight
      ctx.fillStyle = '#b87838';
      ctx.fillRect(bx + 5, by - 10, 1, 2);
      ctx.fillRect(bx + 6, by - 8, 1, 3);
      ctx.fillRect(bx + 7, by - 5, 1, 3);
      ctx.fillRect(bx + 7, by + 6, 1, 3);
      ctx.fillRect(bx + 6, by + 10, 1, 3);
      ctx.fillRect(bx + 5, by + 13, 1, 2);

      // Grip wrap — golden leather
      ctx.fillStyle = '#d4a830';
      ctx.fillRect(bx + 7, by - 1, 2, 8);
      ctx.fillStyle = '#e8c040';
      ctx.fillRect(bx + 7, by, 1, 6);
      // Grip detail lines
      ctx.fillStyle = '#b08820';
      ctx.fillRect(bx + 7, by + 1, 2, 1);
      ctx.fillRect(bx + 7, by + 3, 2, 1);
      ctx.fillRect(bx + 7, by + 5, 2, 1);

      // Nock tips — small metal fittings
      ctx.fillStyle = '#c0c0c0';
      ctx.fillRect(bx + 3, by - 12, 2, 1);
      ctx.fillRect(bx + 3, by + 17, 2, 1);
      ctx.fillStyle = '#e0e0e0';
      ctx.fillRect(bx + 4, by - 12, 1, 1);
      ctx.fillRect(bx + 4, by + 17, 1, 1);

      // Bowstring — thin taut line
      ctx.fillStyle = '#e0d8c0';
      ctx.fillRect(bx + 2, by - 11, 1, 1);
      ctx.fillRect(bx + 1, by - 10, 1, 6);
      ctx.fillRect(bx + 1, by - 4, 1, 4);
      ctx.fillRect(bx + 1, by, 1, 6);
      ctx.fillRect(bx + 1, by + 6, 1, 4);
      ctx.fillRect(bx + 1, by + 10, 1, 4);
      ctx.fillRect(bx + 2, by + 14, 1, 3);
      ctx.fillRect(bx + 2, by + 16, 1, 1);
      // String highlight
      ctx.fillStyle = '#f0ece0';
      ctx.fillRect(bx + 1, by - 2, 1, 2);
      ctx.fillRect(bx + 1, by + 4, 1, 2);

      ctx.restore();
    }
  }

  getNearbyItem(range = 48) {
    for (const item of ROADMAP_ITEMS) {
      const ix = item.mapX * TILE_SIZE + TILE_SIZE / 2;
      const iy = item.mapY * TILE_SIZE + TILE_SIZE / 2;
      const dist = Math.sqrt((this.x - ix) ** 2 + (this.y - iy) ** 2);
      if (dist < range) return item;
    }
    return null;
  }
}

// ============================================================
// PARTICLE SYSTEM
// ============================================================
class ParticleSystem {
  constructor() {
    this.particles = [];
  }

  emit(x, y, count, options = {}) {
    for (let i = 0; i < count; i++) {
      this.particles.push({
        x, y,
        vx: (Math.random() - 0.5) * (options.speed || 3),
        vy: (Math.random() - 0.5) * (options.speed || 3) - (options.upward ? 2 : 0),
        life: options.life || 30 + Math.random() * 30,
        maxLife: options.life || 30 + Math.random() * 30,
        color: options.colors ? options.colors[Math.floor(Math.random() * options.colors.length)] : '#f0c040',
        size: options.size || 2 + Math.random() * 3,
        gravity: options.gravity || 0
      });
    }
  }

  update() {
    this.particles = this.particles.filter(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += p.gravity;
      p.life--;
      return p.life > 0;
    });
  }

  draw(ctx, cameraX, cameraY) {
    for (const p of this.particles) {
      const alpha = p.life / p.maxLife;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = p.color;
      ctx.fillRect(
        Math.round(p.x - cameraX),
        Math.round(p.y - cameraY),
        Math.round(p.size),
        Math.round(p.size)
      );
    }
    ctx.globalAlpha = 1;
  }
}

// ============================================================
// GAME ENGINE
// ============================================================
class Game {
  constructor() {
    this.canvas = document.getElementById('game-canvas');
    this.ctx = this.canvas.getContext('2d');
    this.minimapCanvas = document.getElementById('minimap');
    this.minimapCtx = this.minimapCanvas.getContext('2d');

    this.width = 0;
    this.height = 0;

    // Camera
    this.cameraX = 0;
    this.cameraY = 0;
    this.targetCameraX = 0;
    this.targetCameraY = 0;

    // Input
    this.keys = { up: false, down: false, left: false, right: false };

    // Game state
    this.loaded = false;
    this.tiles = null;
    this.decos = null;
    this.worldMap = null;
    this.character = null;
    this.particles = new ParticleSystem();
    this.activePanel = null;
    this.milestoneShown = new Set();
    this.shownMilestoneBanner = null;
    this.milestoneBannerTimer = 0;
    this.dragonSlain = false;
    this.dragonFightActive = false;
    this.dragonHP = 100;
    this.dragonHitTimer = 0;
    this.arrowsFired = [];
    this.interactCooldown = 0;
    this.coins = [];        // {x, y, collected}
    this.coinsCollected = 0;
    this.totalCoins = 0;
    this.itemGlowPhase = 0;
    this.time = 0;

    // Label visibility tracking
    this.labelFadeIn = {};

    this.init();
  }

  async init() {
    this.resize();
    window.addEventListener('resize', () => this.resize());
    this.setupInput();

    // Simulate loading
    const loadBar = document.getElementById('load-bar');
    const loadText = document.getElementById('load-text');

    loadText.textContent = 'Generating terrain...';
    loadBar.style.width = '20%';
    await this.sleep(300);

    this.tiles = PixelArt.generateTiles();

    // Load PixelLab Wang tilesets in parallel
    loadText.textContent = 'Loading terrain...';
    loadBar.style.width = '35%';
    const [grassPathTiles, grassWaterTiles, grassDarkTiles, grassStoneTiles, grassVolcanicTiles] = await Promise.all([
      PixelArt.loadWangTileset('assets/tilesets/grass_path.png', 'assets/tilesets/grass_path_meta.json'),
      PixelArt.loadWangTileset('assets/tilesets/grass_water.png', 'assets/tilesets/grass_water_meta.json'),
      PixelArt.loadWangTileset('assets/tilesets/grass_darkgrass.png', 'assets/tilesets/grass_darkgrass_meta.json'),
      PixelArt.loadWangTileset('assets/tilesets/grass_stone.png', 'assets/tilesets/grass_stone_meta.json'),
      PixelArt.loadWangTileset('assets/tilesets/grass_volcanic.png', 'assets/tilesets/grass_volcanic_meta.json')
    ]);
    this.wangGrassPath = grassPathTiles;        // lower=grass, upper=path
    this.wangGrassWater = grassWaterTiles;      // lower=grass, upper=water
    this.wangGrassDark = grassDarkTiles;        // lower=grass, upper=darkGrass
    this.wangGrassStone = grassStoneTiles;      // lower=grass, upper=stone
    this.wangGrassVolcanic = grassVolcanicTiles; // lower=grass, upper=volcanic

    // Darken all tileset tiles to reduce bright grass
    const GRASS_DARKEN = 0.2;
    [this.wangGrassPath, this.wangGrassWater, this.wangGrassDark,
     this.wangGrassStone, this.wangGrassVolcanic].forEach(tileset => {
      tileset.forEach(tile => { if (tile) PixelArt.darkenCanvas(tile, GRASS_DARKEN); });
    });

    loadText.textContent = 'Growing forests...';
    loadBar.style.width = '50%';
    await this.sleep(200);

    this.decos = PixelArt.generateDecorations();

    // Replace procedural assets with PixelLab-generated ones
    const loadAssetImg = (src) => new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        const c = document.createElement('canvas');
        c.width = img.width; c.height = img.height;
        c.getContext('2d').drawImage(img, 0, 0);
        resolve(c);
      };
      img.onerror = () => resolve(null); // graceful fallback
      img.src = src;
    });

    const treeCanvas = await loadAssetImg('assets/trees/pine_south.png');
    if (treeCanvas) { this.decos.tree0 = treeCanvas; this.decos.tree1 = treeCanvas; }
    // Flowers, rocks, rose bushes, and boulders use enhanced procedural sprites (already set above)

    // Load PixelLab coin tile
    this.coinSprite = await new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => resolve(null);
      img.src = 'assets/items/coin_iso.png';
    });

    loadText.textContent = 'Summoning Bard the Bowman...';
    loadBar.style.width = '60%';

    const charSprites = await PixelArt.loadCharacterSprites();
    loadText.textContent = 'Awakening the dragon...';
    loadBar.style.width = '80%';
    await this.sleep(200);

    this.worldMap = new WorldMap();
    this.character = new Character(4 * TILE_SIZE, 10 * TILE_SIZE);
    this.character.loadSprites(charSprites);

    // Generate coins along the path
    this.generateCoins();

    loadText.textContent = 'Quest begins!';
    loadBar.style.width = '100%';
    await this.sleep(400);

    document.getElementById('loading').style.display = 'none';

    // Show title screen
    const titleScreen = document.getElementById('title-screen');
    titleScreen.style.display = 'flex';

    // Pre-render minimap and a single frame so background is visible behind title
    this.renderMinimap();
    // Render one frame behind the title screen overlay
    this.loaded = true;
    this.draw();
    this.loaded = false;

    // Wait briefly then listen for any key or click to start
    await this.sleep(500);
    await new Promise(resolve => {
      const start = (e) => {
        // Ignore modifier keys alone
        if (e instanceof KeyboardEvent && ['Shift','Control','Alt','Meta'].includes(e.key)) return;
        titleScreen.style.display = 'none';
        window.removeEventListener('keydown', start);
        titleScreen.removeEventListener('click', start);
        resolve();
      };
      window.addEventListener('keydown', start);
      titleScreen.addEventListener('click', start);
    });

    this.loaded = true;

    // Start game loop
    this.loop();
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  resize() {
    this.width = window.innerWidth;
    this.height = window.innerHeight;
    this.canvas.width = this.width;
    this.canvas.height = this.height;
    this.ctx.imageSmoothingEnabled = false;
  }

  // Compute Wang tile index for a cell based on which neighbor terrain matches 'upperTerrain'
  // Each corner vertex checks the 4 tiles sharing it; if any is the upper terrain, that corner = 1
  getWangIndex(col, row, upperTerrain) {
    const grid = this.worldMap.grid;
    const rows = this.worldMap.rows;
    const cols = this.worldMap.cols;

    const isUpper = (c, r) => {
      if (c < 0 || r < 0 || c >= cols || r >= rows) return false;
      return grid[r][c] === upperTerrain;
    };

    // NW vertex at (col, row): shared by tiles (col-1,row-1), (col,row-1), (col-1,row), (col,row)
    const nw = (isUpper(col-1,row-1) || isUpper(col,row-1) || isUpper(col-1,row) || isUpper(col,row)) ? 1 : 0;
    // NE vertex at (col+1, row): shared by tiles (col,row-1), (col+1,row-1), (col,row), (col+1,row)
    const ne = (isUpper(col,row-1) || isUpper(col+1,row-1) || isUpper(col,row) || isUpper(col+1,row)) ? 1 : 0;
    // SW vertex at (col, row+1): shared by tiles (col-1,row), (col,row), (col-1,row+1), (col,row+1)
    const sw = (isUpper(col-1,row) || isUpper(col,row) || isUpper(col-1,row+1) || isUpper(col,row+1)) ? 1 : 0;
    // SE vertex at (col+1, row+1): shared by tiles (col,row), (col+1,row), (col,row+1), (col+1,row+1)
    const se = (isUpper(col,row) || isUpper(col+1,row) || isUpper(col,row+1) || isUpper(col+1,row+1)) ? 1 : 0;

    return nw * 8 + ne * 4 + sw * 2 + se;
  }

  setupInput() {
    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') { this.keys.up = true; e.preventDefault(); }
      if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') { this.keys.down = true; e.preventDefault(); }
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') { this.keys.left = true; e.preventDefault(); }
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') { this.keys.right = true; e.preventDefault(); }
    });

    window.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') this.keys.up = false;
      if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') this.keys.down = false;
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') this.keys.left = false;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') this.keys.right = false;
    });

    // No click-to-move — keyboard only
  }

  closePanel() {
    this.activePanel = null;
    const panel = document.getElementById('info-panel');
    panel.classList.remove('visible');
  }

  interactWithItem(item) {
    if (item.status === 'milestone') {
      this.activePanel = item; // Track so we don't re-trigger every frame
      if (item.id === 'milestone2' && !this.dragonSlain) {
        this.startDragonFight();
      }
      // Bow pickup
      if (item.id === 'milestone1' && !this.character.hasBow) {
        this.character.hasBow = true;
      }
      // Show milestone banner
      if (!this.milestoneShown.has(item.id)) {
        this.milestoneShown.add(item.id);
        this.showMilestoneBanner(item.title);
      }
      return;
    }

    this.character.visitedItems.add(item.id);
    this.activePanel = item;

    const panel = document.getElementById('info-panel');
    const status = document.getElementById('panel-status');
    const title = document.getElementById('panel-title');
    const desc = document.getElementById('panel-desc');

    if (item.status === 'shipped') {
      status.textContent = '✓ SHIPPED — CONQUERED';
      status.className = 'panel-status';
    } else {
      status.textContent = '★ POWER-UP — ON THE ROADMAP';
      status.className = 'panel-status upcoming';
    }

    title.innerHTML = `<span class="panel-number">${item.id}</span>${item.title}`;
    desc.textContent = item.description;
    panel.classList.add('visible');
  }

  showMilestoneBanner(text) {
    this.shownMilestoneBanner = text;
    this.milestoneBannerTimer = 180;
    const banner = document.getElementById('milestone-banner');
    const bannerText = document.getElementById('banner-text');
    bannerText.textContent = text.replace('\n', ' ');
    banner.classList.add('visible');
  }

  generateCoins() {
    // Place coins along the path between waypoints, spaced ~4 tiles apart
    const waypoints = [
      { x: 4, y: 10 }, { x: 16, y: 10 }, { x: 30, y: 10 },
      { x: 30, y: 24 }, { x: 44, y: 24 }, { x: 44, y: 12 },
      { x: 58, y: 12 }, { x: 58, y: 38 }, { x: 44, y: 38 },
      { x: 44, y: 52 }
    ];
    const COIN_SPACING = 3; // tiles between coins
    const coins = [];

    for (let i = 0; i < waypoints.length - 1; i++) {
      const from = waypoints[i];
      const to = waypoints[i + 1];
      const dx = to.x - from.x;
      const dy = to.y - from.y;
      const dist = Math.max(Math.abs(dx), Math.abs(dy));
      const steps = Math.floor(dist / COIN_SPACING);

      for (let s = 1; s <= steps; s++) {
        const t = s / (steps + 1);
        const cx = from.x + dx * t;
        const cy = from.y + dy * t;

        // Skip if too close to any roadmap item
        const tooClose = ROADMAP_ITEMS.some(item =>
          Math.abs(item.mapX - cx) < 2 && Math.abs(item.mapY - cy) < 2
        );
        if (!tooClose) {
          coins.push({
            x: cx * TILE_SIZE + TILE_SIZE / 2,
            y: cy * TILE_SIZE + TILE_SIZE / 2,
            collected: false,
            collectAnim: 0 // animation timer when collected
          });
        }
      }
    }

    this.coins = coins;
    this.totalCoins = coins.length;
    this.coinsCollected = 0;
  }

  updateCoins() {
    const pickupRadius = 20;
    for (const coin of this.coins) {
      if (coin.collected) {
        if (coin.collectAnim > 0) coin.collectAnim--;
        continue;
      }
      const dx = this.character.x - coin.x;
      const dy = this.character.y - coin.y;
      if (dx * dx + dy * dy < pickupRadius * pickupRadius) {
        coin.collected = true;
        coin.collectAnim = 15; // float-up animation frames
        this.coinsCollected++;
        this.character.jumpTimer = 12; // trigger jump
      }
    }
  }

  drawCoins(ctx, cx, cy) {
    const spinPhase = this.time * 0.1;
    const useSpriteImg = this.coinSprite;
    const sprW = useSpriteImg ? useSpriteImg.width : 0;
    const sprH = useSpriteImg ? useSpriteImg.height : 0;

    for (const coin of this.coins) {
      if (coin.collected && coin.collectAnim <= 0) continue;

      const sx = coin.x - cx;
      const sy = coin.y - cy;

      if (coin.collected) {
        // Float-up and fade out animation
        const progress = 1 - coin.collectAnim / 15;
        ctx.globalAlpha = 1 - progress;
        const floatY = sy - progress * 24;

        if (useSpriteImg) {
          const scale = 0.7 * (1 - progress * 0.3);
          ctx.drawImage(useSpriteImg,
            sx - sprW * scale / 2, floatY - sprH * scale / 2,
            sprW * scale, sprH * scale);
        } else {
          ctx.fillStyle = '#f0c040';
          ctx.fillRect(sx - 4, floatY - 5, 8, 10);
          ctx.fillStyle = '#fff8d0';
          ctx.fillRect(sx - 2, floatY - 3, 4, 4);
        }

        // +1 text
        ctx.fillStyle = '#f0d060';
        ctx.fillRect(sx + 6, floatY - 10, 1, 5);
        ctx.fillRect(sx + 4, floatY - 8, 5, 1);
        ctx.fillRect(sx + 10, floatY - 10, 2, 5);
        ctx.fillRect(sx + 9, floatY - 10, 1, 1);

        ctx.globalAlpha = 1;
      } else {
        const hover = Math.sin(this.time * 0.05 + coin.x * 0.01 + coin.y * 0.005) * 2;
        const spinScale = Math.abs(Math.cos(spinPhase + coin.x * 0.02));

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fillRect(sx - 5, sy + 8 + hover, 10, 3);

        if (useSpriteImg) {
          // Draw PixelLab coin sprite with spinning scale on X axis
          const drawW = sprW * 0.7 * (spinScale * 0.7 + 0.3);
          const drawH = sprH * 0.7;
          ctx.drawImage(useSpriteImg,
            sx - drawW / 2, sy - drawH / 2 + hover,
            drawW, drawH);

          // Bright shine overlay when front-facing
          if (spinScale > 0.7) {
            ctx.globalAlpha = (spinScale - 0.7) / 0.3 * 0.5;
            ctx.fillStyle = '#fff8d0';
            ctx.fillRect(sx - 3, sy - 4 + hover, 3, 3);
            ctx.globalAlpha = 1;
          }
        } else {
          // Fallback procedural coin
          const spinW = spinScale * 8 + 2;
          const coinH = 10;

          ctx.fillStyle = '#a07010';
          ctx.fillRect(sx - spinW / 2 - 1, sy - coinH / 2 + hover - 1, spinW + 2, coinH + 2);
          ctx.fillStyle = '#d4a020';
          ctx.fillRect(sx - spinW / 2, sy - coinH / 2 + hover, spinW, coinH);
          if (spinW > 4) {
            ctx.fillStyle = '#f0d060';
            ctx.fillRect(sx - spinW / 2 + 1, sy - coinH / 2 + 1 + hover, spinW - 2, 3);
            ctx.fillStyle = '#fff8d0';
            ctx.fillRect(sx - spinW / 2 + 1, sy - coinH / 2 + 1 + hover, 2, 2);
          }
          ctx.fillStyle = '#9a6808';
          ctx.fillRect(sx - spinW / 2, sy + coinH / 2 - 1 + hover, spinW, 1);
        }
      }
    }
  }

  startDragonFight() {
    this.dragonFightActive = true;
    this.dragonHP = 100;
    this.arrowsFired = [];
    this.dragonHitTimer = 0;
    this.closePanel();
  }

  fireDragonArrow() {
    const dragon = ROADMAP_ITEMS.find(i => i.id === 'milestone2');
    const dx = dragon.mapX * TILE_SIZE + 48 - this.character.x;
    const dy = dragon.mapY * TILE_SIZE + 48 - this.character.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    this.arrowsFired.push({
      x: this.character.x,
      y: this.character.y - 8,
      vx: (dx / dist) * 8,
      vy: (dy / dist) * 8,
      life: 60
    });
  }

  updateDragonFight() {
    if (!this.dragonFightActive) return;

    // Auto-fire arrows
    if (this.time % 15 === 0) {
      this.fireDragonArrow();
    }

    // Update arrows
    const dragon = ROADMAP_ITEMS.find(i => i.id === 'milestone2');
    const dragonX = dragon.mapX * TILE_SIZE + 48;
    const dragonY = dragon.mapY * TILE_SIZE + 48;

    this.arrowsFired = this.arrowsFired.filter(arrow => {
      arrow.x += arrow.vx;
      arrow.y += arrow.vy;
      arrow.life--;

      // Hit detection
      const dist = Math.sqrt((arrow.x - dragonX) ** 2 + (arrow.y - dragonY) ** 2);
      if (dist < 40) {
        this.dragonHP -= 8;
        this.dragonHitTimer = 10;
        this.particles.emit(dragonX, dragonY, 10, {
          colors: ['#ff4040', '#ff8040', '#ffff40'],
          speed: 5,
          gravity: 0.1
        });
        return false;
      }

      return arrow.life > 0;
    });

    // Dragon defeated
    if (this.dragonHP <= 0 && !this.dragonSlain) {
      this.dragonSlain = true;
      this.dragonFightActive = false;
      // Victory particles
      for (let i = 0; i < 5; i++) {
        setTimeout(() => {
          this.particles.emit(dragonX + (Math.random()-0.5)*60, dragonY + (Math.random()-0.5)*60, 30, {
            colors: ['#f0c040', '#ff8020', '#ff4040', '#fff', '#40e040'],
            speed: 8,
            upward: true,
            life: 80,
            gravity: -0.05
          });
        }, i * 200);
      }
      this.showMilestoneBanner('DRAGON SLAIN!\nTHE QUEST IS COMPLETE');
    }
  }

  drawArrows(ctx) {
    for (const arrow of this.arrowsFired) {
      const sx = arrow.x - this.cameraX;
      const sy = arrow.y - this.cameraY;
      const angle = Math.atan2(arrow.vy, arrow.vx);
      ctx.save();
      ctx.translate(sx, sy);
      ctx.rotate(angle);
      // Arrow shaft
      ctx.fillStyle = '#b08040';
      ctx.fillRect(-8, -1, 16, 2);
      // Arrowhead (metal tip)
      ctx.fillStyle = '#888';
      ctx.fillRect(6, -2, 4, 1);
      ctx.fillRect(7, -1, 4, 2);
      ctx.fillRect(6, 1, 4, 1);
      ctx.fillStyle = '#aaa';
      ctx.fillRect(8, -1, 3, 2);
      // Fletching (red feathers at back)
      ctx.fillStyle = '#cc3030';
      ctx.fillRect(-8, -3, 4, 2);
      ctx.fillRect(-8, 1, 4, 2);
      ctx.fillStyle = '#a02020';
      ctx.fillRect(-7, -2, 2, 1);
      ctx.fillRect(-7, 1, 2, 1);
      ctx.restore();
    }
  }

  update() {
    if (!this.loaded) return;

    this.time++;
    this.itemGlowPhase += 0.03;

    // Update character with keyboard input only
    this.character.update(this.keys, this.worldMap);

    // Camera follow — account for zoom (viewport is smaller in world coords)
    const viewW = this.width / ZOOM;
    const viewH = this.height / ZOOM;
    this.targetCameraX = this.character.x - viewW / 2;
    this.targetCameraY = this.character.y - viewH / 2;

    // Clamp camera
    const maxCX = MAP_COLS * TILE_SIZE - viewW;
    const maxCY = MAP_ROWS * TILE_SIZE - viewH;
    this.targetCameraX = Math.max(0, Math.min(this.targetCameraX, maxCX));
    this.targetCameraY = Math.max(0, Math.min(this.targetCameraY, maxCY));

    this.cameraX += (this.targetCameraX - this.cameraX) * CAMERA_SMOOTH;
    this.cameraY += (this.targetCameraY - this.cameraY) * CAMERA_SMOOTH;

    // Auto-show info panel and milestones on proximity
    const nearbyItem = this.character.getNearbyItem(60);
    if (nearbyItem) {
      if (nearbyItem !== this.activePanel) {
        this.interactWithItem(nearbyItem);
      }
    } else if (this.activePanel) {
      this.closePanel();
    }

    // Milestone banner timer
    if (this.milestoneBannerTimer > 0) {
      this.milestoneBannerTimer--;
      if (this.milestoneBannerTimer === 0) {
        document.getElementById('milestone-banner').classList.remove('visible');
      }
    }

    // Coin collection
    this.updateCoins();

    // Dragon fight
    this.updateDragonFight();

    // Particles (only for dragon fight effects)
    this.particles.update();

    // Update quest progress
    const visited = this.character.visitedItems.size;
    const total = ROADMAP_ITEMS.filter(i => i.status !== 'milestone').length;
    document.getElementById('quest-progress').textContent =
      `Discoveries: ${visited}/${total}` + (this.dragonSlain ? ' | DRAGON SLAIN' : '');
    document.getElementById('coin-counter').textContent =
      `Coins: ${this.coinsCollected}/${this.totalCoins}`;
  }

  draw() {
    if (!this.loaded) return;

    const ctx = this.ctx;
    const cx = Math.round(this.cameraX);
    const cy = Math.round(this.cameraY);
    const viewW = this.width / ZOOM;
    const viewH = this.height / ZOOM;

    // Clear at full resolution
    ctx.fillStyle = '#0a0a1a';
    ctx.fillRect(0, 0, this.width, this.height);

    // Apply zoom
    ctx.save();
    ctx.scale(ZOOM, ZOOM);

    // Calculate visible tile range (in zoomed view)
    const startCol = Math.max(0, Math.floor(cx / TILE_SIZE) - 1);
    const endCol = Math.min(this.worldMap.cols - 1, Math.ceil((cx + viewW) / TILE_SIZE) + 1);
    const startRow = Math.max(0, Math.floor(cy / TILE_SIZE) - 1);
    const endRow = Math.min(this.worldMap.rows - 1, Math.ceil((cy + viewH) / TILE_SIZE) + 1);

    // Draw tiles with Wang autotiling for all terrain types
    for (let row = startRow; row <= endRow; row++) {
      for (let col = startCol; col <= endCol; col++) {
        const tile = this.worldMap.grid[row][col];
        const drawX = col * TILE_SIZE - cx;
        const drawY = row * TILE_SIZE - cy;

        // Layer Wang transitions: draw base then overlay each terrain transition
        // This avoids grass strips between non-grass terrains (e.g. darkGrass → water)
        const darkWang = this.getWangIndex(col, row, 'darkGrass');
        const stoneWang = this.getWangIndex(col, row, 'stone');
        const volcanicWang = this.getWangIndex(col, row, 'volcanic');
        const waterWang = this.getWangIndex(col, row, 'water');
        const pathWang = this.getWangIndex(col, row, 'path');

        // Base grass tile always drawn first
        const baseTile = this.wangGrassPath[0];
        if (baseTile) ctx.drawImage(baseTile, drawX, drawY);

        // Layer terrains from lowest to highest priority
        if (darkWang > 0 && this.wangGrassDark[darkWang])
          ctx.drawImage(this.wangGrassDark[darkWang], drawX, drawY);
        if (stoneWang > 0 && this.wangGrassStone[stoneWang])
          ctx.drawImage(this.wangGrassStone[stoneWang], drawX, drawY);
        if (volcanicWang > 0 && this.wangGrassVolcanic[volcanicWang])
          ctx.drawImage(this.wangGrassVolcanic[volcanicWang], drawX, drawY);
        if (waterWang > 0 && this.wangGrassWater[waterWang])
          ctx.drawImage(this.wangGrassWater[waterWang], drawX, drawY);
        if (pathWang > 0 && this.wangGrassPath[pathWang])
          ctx.drawImage(this.wangGrassPath[pathWang], drawX, drawY);
      }
    }

    // Animate water shimmer
    if (this.time % 40 < 20) {
      ctx.fillStyle = 'rgba(100,160,255,0.1)';
      for (let row = startRow; row <= endRow; row++) {
        for (let col = startCol; col <= endCol; col++) {
          if (this.worldMap.grid[row][col] === 'water') {
            ctx.fillRect(col * TILE_SIZE - cx, row * TILE_SIZE - cy, TILE_SIZE, TILE_SIZE);
          }
        }
      }
    }

    // Draw path direction dots (breadcrumbs following right-angle path)
    ctx.globalAlpha = 0.25 + Math.sin(this.time * 0.04) * 0.1;
    ctx.fillStyle = '#f0d080';
    // Build waypoints matching the winding path
    const breadcrumbWaypoints = [
      { x: 4, y: 10 },   // start
      { x: 16, y: 10 },  // item 1
      { x: 30, y: 10 },  // item 2
      { x: 30, y: 24 },  // item 3
      { x: 44, y: 24 },  // milestone1
      { x: 44, y: 12 },  // item 4
      { x: 58, y: 12 },  // item 5
      { x: 58, y: 38 },  // item 6
      { x: 44, y: 38 },  // item 7
      { x: 44, y: 52 },  // dragon
    ].map(p => ({ x: p.x * TILE_SIZE + TILE_SIZE/2, y: p.y * TILE_SIZE + TILE_SIZE/2 }));

    for (let i = 0; i < breadcrumbWaypoints.length - 1; i++) {
      const from = breadcrumbWaypoints[i];
      const to = breadcrumbWaypoints[i + 1];
      const dx = to.x - from.x;
      const dy = to.y - from.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const dots = Math.floor(dist / 40);
      for (let d = 1; d < dots; d++) {
        const t = d / dots;
        const px = from.x + dx * t - cx;
        const py = from.y + dy * t - cy;
        ctx.fillRect(Math.round(px) - 2, Math.round(py) - 2, 4, 4);
      }
    }
    ctx.globalAlpha = 1;

    // Draw zone section labels on the terrain
    this.drawZoneLabels(ctx, cx, cy);

    // Draw coins on path
    this.drawCoins(ctx, cx, cy);

    // Draw decorations (behind character based on y-sort)
    const charY = this.character.y;
    for (const deco of this.worldMap.decorations) {
      const decoWorldY = deco.y * TILE_SIZE + TILE_SIZE;
      if (decoWorldY < charY + 4) {
        this.drawDecoration(ctx, deco, cx, cy);
      }
    }

    // Draw roadmap items (behind character)
    for (const item of ROADMAP_ITEMS) {
      const itemWorldY = item.mapY * TILE_SIZE + TILE_SIZE;
      if (itemWorldY < charY + 4) {
        this.drawRoadmapItem(ctx, item, cx, cy);
      }
    }

    // Draw character
    this.character.draw(ctx, cx, cy);

    // Draw decorations (in front of character)
    for (const deco of this.worldMap.decorations) {
      const decoWorldY = deco.y * TILE_SIZE + TILE_SIZE;
      if (decoWorldY >= charY + 4) {
        this.drawDecoration(ctx, deco, cx, cy);
      }
    }

    // Draw roadmap items (in front of character)
    for (const item of ROADMAP_ITEMS) {
      const itemWorldY = item.mapY * TILE_SIZE + TILE_SIZE;
      if (itemWorldY >= charY + 4) {
        this.drawRoadmapItem(ctx, item, cx, cy);
      }
    }

    // Draw arrows
    this.drawArrows(ctx);

    // Draw particles on top (dragon fight only)
    this.particles.draw(ctx, cx, cy);

    // Draw item labels (in world space)
    this.drawItemLabels(ctx, cx, cy);

    // End zoom context
    ctx.restore();

    // --- HUD elements drawn at screen resolution (no zoom) ---

    // Draw dragon HP bar
    if (this.dragonFightActive) {
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(this.width/2 - 152, 110, 304, 40);
      ctx.fillStyle = '#600';
      ctx.fillRect(this.width/2 - 150, 112, 300, 36);
      ctx.fillStyle = '#c03030';
      ctx.fillRect(this.width/2 - 150, 112, this.dragonHP * 3, 36);
      ctx.fillStyle = '#e04040';
      ctx.fillRect(this.width/2 - 150, 112, this.dragonHP * 3, 14);

      ctx.font = '16px "Press Start 2P"';
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.fillText('THE DRAGON', this.width/2, 100);
      ctx.textAlign = 'start';
    }

    // Update minimap
    if (this.time % 10 === 0) {
      this.updateMinimapDot();
    }
  }

  drawZoneLabels(ctx, cx, cy) {
    // Section 1: Foundation (shipped) — top-left area near start
    const sec1X = 22 * TILE_SIZE - cx;
    const sec1Y = 6 * TILE_SIZE - cy;
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.font = '16px "Press Start 2P"';
    ctx.fillStyle = '#40e040';
    ctx.textAlign = 'center';
    ctx.fillText('FOUNDATION', sec1X, sec1Y);
    ctx.font = '7px "Press Start 2P"';
    ctx.fillText('Shipped & Conquered', sec1X, sec1Y + 24);
    ctx.restore();

    // Section 2: Power-Ups (upcoming) — mid-right area
    const sec2X = 52 * TILE_SIZE - cx;
    const sec2Y = 20 * TILE_SIZE - cy;
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.font = '16px "Press Start 2P"';
    ctx.fillStyle = '#f0c040';
    ctx.textAlign = 'center';
    ctx.fillText('POWER-UPS', sec2X, sec2Y);
    ctx.font = '7px "Press Start 2P"';
    ctx.fillText('On the Roadmap', sec2X, sec2Y + 24);
    ctx.restore();

    // Dragon Lair label
    const sec3X = 44 * TILE_SIZE - cx;
    const sec3Y = 48 * TILE_SIZE - cy;
    ctx.save();
    ctx.globalAlpha = 0.15;
    ctx.font = '14px "Press Start 2P"';
    ctx.fillStyle = '#c03030';
    ctx.textAlign = 'center';
    ctx.fillText('DRAGON LAIR', sec3X, sec3Y);
    ctx.restore();
  }

  drawDecoration(ctx, deco, cx, cy) {
    const sprite = this.decos[deco.type];
    if (!sprite) return;
    const drawX = deco.x * TILE_SIZE - cx;
    const drawY = deco.y * TILE_SIZE - cy - (sprite.height - TILE_SIZE);
    ctx.drawImage(sprite, drawX, drawY);
  }

  drawRoadmapItem(ctx, item, cx, cy) {
    const sprite = this.decos[item.icon];
    if (!sprite) return;

    const drawX = item.mapX * TILE_SIZE - cx;
    const drawY = item.mapY * TILE_SIZE - cy;
    const centerX = drawX + TILE_SIZE / 2;

    // Dragon special handling
    if (item.icon === 'dragon') {
      if (this.dragonSlain) {
        // Draw fallen dragon (flipped, faded)
        ctx.globalAlpha = 0.5;
        ctx.save();
        ctx.translate(drawX + 48, drawY + 48);
        ctx.scale(1, -1);
        ctx.drawImage(sprite, -48, -48);
        ctx.restore();
        ctx.globalAlpha = 1;

        // Victory flag
        ctx.drawImage(this.decos.flag, drawX + 32, drawY - 32);
      } else {
        // Breathing animation
        const breathOffset = Math.sin(this.time * 0.05) * 2;
        const hitFlash = this.dragonHitTimer > 0;
        if (hitFlash) {
          ctx.globalAlpha = 0.5 + Math.random() * 0.5;
          this.dragonHitTimer--;
        }
        ctx.drawImage(sprite, drawX - 16, drawY - sprite.height + TILE_SIZE + breathOffset);
        ctx.globalAlpha = 1;

        // Fire breath particles
        if (this.dragonFightActive && this.time % 8 === 0) {
          this.particles.emit(
            item.mapX * TILE_SIZE + 90,
            item.mapY * TILE_SIZE + 36,
            3,
            { colors: ['#f08020', '#f0c040', '#ff4020'], speed: 4, life: 20 }
          );
        }
      }
      return;
    }

    // Draw the icon
    if (item.icon === 'tower') {
      ctx.drawImage(sprite, drawX - TILE_SIZE/2, drawY - sprite.height + TILE_SIZE);
      // Checkmark for shipped
      if (item.status === 'shipped') {
        ctx.drawImage(this.decos.checkmark, drawX + TILE_SIZE - 4, drawY - 8);
      }
    } else if (item.icon === 'chest') {
      ctx.drawImage(sprite, drawX, drawY);
    } else if (item.icon === 'flag') {
      const flagWave = Math.sin(this.time * 0.1) * 2;
      ctx.drawImage(sprite, drawX, drawY - TILE_SIZE + flagWave);
    } else if (item.icon === 'bow') {
      // Only draw bow on map if character hasn't picked it up yet
      if (!this.character.hasBow) {
        const hover = Math.sin(this.time * 0.06) * 3;
        // Glow pulse around bow
        const glowAlpha = 0.15 + Math.sin(this.time * 0.04) * 0.1;
        ctx.fillStyle = `rgba(255, 220, 80, ${glowAlpha})`;
        ctx.beginPath();
        ctx.arc(centerX, drawY - TILE_SIZE / 2 + hover, 20, 0, Math.PI * 2);
        ctx.fill();
        ctx.drawImage(sprite, drawX, drawY - TILE_SIZE + hover);
      }
    }

    // Draw numbered circle on each stop (not milestones)
    if (typeof item.id === 'number') {
      const numX = centerX;
      const numY = item.icon === 'tower' ? drawY - sprite.height + TILE_SIZE - 6 : drawY - 6;
      const radius = 10;

      // Circle background
      ctx.fillStyle = item.status === 'shipped' ? '#2a8a2a' : '#a07020';
      ctx.beginPath();
      ctx.arc(numX, numY, radius, 0, Math.PI * 2);
      ctx.fill();
      // Circle border
      ctx.strokeStyle = item.status === 'shipped' ? '#40e040' : '#f0c040';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(numX, numY, radius, 0, Math.PI * 2);
      ctx.stroke();
      // Number
      ctx.font = '8px "Press Start 2P"';
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(item.id), numX, numY);
      ctx.textAlign = 'start';
      ctx.textBaseline = 'alphabetic';
    }
  }

  drawItemLabels(ctx, cx, cy) {
    ctx.font = '8px "Press Start 2P"';
    ctx.textAlign = 'center';

    for (const item of ROADMAP_ITEMS) {
      if (item.status === 'milestone') continue;

      const drawX = item.mapX * TILE_SIZE + TILE_SIZE/2 - cx;
      const drawY = item.mapY * TILE_SIZE - cy;

      // Only show labels when somewhat nearby
      const dist = Math.sqrt(
        (this.character.x - item.mapX * TILE_SIZE) ** 2 +
        (this.character.y - item.mapY * TILE_SIZE) ** 2
      );

      const maxDist = 500;
      if (dist > maxDist) continue;

      const alpha = Math.min(1, (maxDist - dist) / 200);

      // Label background
      const labelY = item.icon === 'tower' ? drawY - 52 : drawY - 22;
      const label = item.title;
      const metrics = ctx.measureText(label);
      const labelW = metrics.width + 16;
      const labelH = 18;

      ctx.globalAlpha = alpha * 0.85;
      ctx.fillStyle = 'rgba(0,0,0,0.75)';
      ctx.fillRect(drawX - labelW/2, labelY - 10, labelW, labelH);

      ctx.globalAlpha = alpha;

      if (item.status === 'shipped') {
        ctx.fillStyle = '#80ff80';
        ctx.fillRect(drawX - labelW/2 + 3, labelY - 7, 4, 4);
        ctx.fillStyle = '#40e040';
        ctx.fillRect(drawX - labelW/2 + 3, labelY - 2, 4, 4);
      } else {
        ctx.fillStyle = '#f0c040';
        ctx.fillRect(drawX - labelW/2 + 3, labelY - 5, 4, 4);
      }

      ctx.fillStyle = item.status === 'shipped' ? '#c0ffc0' : '#ffe080';
      ctx.fillText(label, drawX, labelY + 2);

      ctx.globalAlpha = 1;
    }

    ctx.textAlign = 'start';
  }

  renderMinimap() {
    const mCtx = this.minimapCtx;
    const mW = this.minimapCanvas.width;
    const mH = this.minimapCanvas.height;
    const scaleX = mW / (MAP_COLS * TILE_SIZE);
    const scaleY = mH / (MAP_ROWS * TILE_SIZE);

    mCtx.fillStyle = '#1a1a2a';
    mCtx.fillRect(0, 0, mW, mH);

    // Draw simplified map
    for (let y = 0; y < MAP_ROWS; y++) {
      for (let x = 0; x < MAP_COLS; x++) {
        const tile = this.worldMap.grid[y][x];
        let color = '#2a5a2a';
        if (tile === 'path') color = '#a08050';
        else if (tile === 'water') color = '#2050a0';
        else if (tile === 'darkGrass') color = '#1a3a1a';
        else if (tile === 'stone') color = '#505060';
        else if (tile === 'volcanic') color = '#3a1515';

        mCtx.fillStyle = color;
        mCtx.fillRect(
          Math.floor(x * TILE_SIZE * scaleX),
          Math.floor(y * TILE_SIZE * scaleY),
          Math.ceil(TILE_SIZE * scaleX) + 1,
          Math.ceil(TILE_SIZE * scaleY) + 1
        );
      }
    }

    // Draw roadmap items on minimap
    for (const item of ROADMAP_ITEMS) {
      const mx = item.mapX * TILE_SIZE * scaleX;
      const my = item.mapY * TILE_SIZE * scaleY;
      if (item.status === 'shipped') {
        mCtx.fillStyle = '#40e040';
      } else if (item.status === 'upcoming') {
        mCtx.fillStyle = '#f0c040';
      } else if (item.icon === 'dragon') {
        mCtx.fillStyle = '#c03030';
      } else {
        mCtx.fillStyle = '#f0c040';
      }
      mCtx.fillRect(mx - 2, my - 2, 5, 5);
    }
  }

  updateMinimapDot() {
    // Refresh the static minimap, then draw the player dot
    this.renderMinimap();

    const mCtx = this.minimapCtx;
    const scaleX = this.minimapCanvas.width / (MAP_COLS * TILE_SIZE);
    const scaleY = this.minimapCanvas.height / (MAP_ROWS * TILE_SIZE);
    const px = this.character.x * scaleX;
    const py = this.character.y * scaleY;

    // Player dot (blinking)
    mCtx.fillStyle = this.time % 30 < 20 ? '#fff' : '#f0c040';
    mCtx.fillRect(px - 2, py - 2, 4, 4);

    // Camera viewport rectangle (accounting for zoom)
    mCtx.strokeStyle = 'rgba(255,255,255,0.3)';
    mCtx.lineWidth = 1;
    mCtx.strokeRect(
      this.cameraX * scaleX,
      this.cameraY * scaleY,
      (this.width / ZOOM) * scaleX,
      (this.height / ZOOM) * scaleY
    );
  }

  loop() {
    this.update();
    this.draw();
    requestAnimationFrame(() => this.loop());
  }
}

// ============================================================
// GLOBAL FUNCTIONS
// ============================================================
function closePanel() {
  game.closePanel();
}

// Start the game
const game = new Game();

  </script>
</body>
</html>
