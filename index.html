<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Dictation Quest — Corti API Roadmap</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Silkscreen:wght@400;700&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0a0a1a;
      overflow: hidden;
      font-family: 'Press Start 2P', monospace;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      cursor: default;
      user-select: none;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      overscroll-behavior: none;
    }

    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      touch-action: none;
    }

    /* HUD overlay */
    #hud {
      position: absolute;
      top: 0; left: 0; right: 0;
      padding: 16px 24px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
      pointer-events: none;
      z-index: 10;
    }

    #hud .title {
      font-size: 20px;
      color: #f0c040;
      text-shadow: 2px 2px 0 #000;
      letter-spacing: 2px;
    }

    #hud .subtitle {
      font-size: 12px;
      color: #b0b0c0;
      margin-top: 6px;
      text-shadow: 1px 1px 0 #000, 0 0 4px rgba(0,0,0,0.8);
    }

    #hud .quest-info {
      text-align: right;
      font-size: 12px;
      color: #90e090;
      text-shadow: 1px 1px 0 #000, 0 0 4px rgba(0,0,0,0.8);
    }

    /* Info panel — medieval scroll / parchment aesthetic */
    #info-panel {
      position: absolute;
      bottom: calc(24px + env(safe-area-inset-bottom, 0px));
      left: 50%;
      transform: translateX(-50%);
      max-width: 520px;
      width: 92%;
      background: linear-gradient(180deg, #efe6d4 0%, #d9ccb8 100%);
      border: 4px solid #4a3520;
      border-radius: 4px;
      padding: 20px 24px 20px 24px;
      z-index: 20;
      display: none;
      box-shadow: 
        0 0 0 2px #6b5344,
        0 8px 24px rgba(0,0,0,0.4),
        inset 0 1px 0 rgba(255,255,255,0.3);
    }

    #info-panel.visible {
      display: block;
      animation: panelSlideUp 0.25s ease-out;
    }

    @keyframes panelSlideUp {
      from { transform: translateX(-50%) translateY(24px); opacity: 0; }
      to { transform: translateX(-50%) translateY(0); opacity: 1; }
    }

    #info-panel .panel-status {
      font-size: 9px;
      color: #3d5c2e;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 2px;
      font-family: 'Press Start 2P', monospace;
    }

    #info-panel .panel-status.upcoming {
      color: #6b5020;
    }
    #info-panel .panel-status.pitfall {
      color: #8a1f1f;
    }

    #info-panel .panel-title {
      font-size: 11px;
      color: #2a1f14;
      margin-bottom: 14px;
      text-shadow: 1px 1px 0 rgba(255,255,255,0.5);
      line-height: 1.7;
      font-family: 'Press Start 2P', monospace;
    }

    #info-panel .panel-desc {
      font-family: 'Press Start 2P', monospace;
      font-size: 9px;
      color: #3d3528;
      line-height: 2.0;
      text-transform: none;
      text-shadow: 0 1px 0 rgba(255,255,255,0.4);
      max-height: 38vh;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      margin-bottom: 16px;
    }

    #info-panel .panel-actions {
      display: flex;
      gap: 12px;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
    }

    #info-panel .panel-number {
      display: inline-block;
      background: #4a3520;
      color: #efe6d4;
      padding: 4px 10px;
      margin-right: 10px;
      font-size: 10px;
      font-family: 'Press Start 2P', monospace;
      border-radius: 2px;
    }

    /* Milestone banner */
    #milestone-banner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 25;
      text-align: center;
      display: none;
      pointer-events: none;
      max-width: min(90vw, 520px);
      padding: 0 20px;
    }

    #milestone-banner.visible {
      display: block;
      animation: milestonePulse 0.5s ease-out;
    }

    @keyframes milestonePulse {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      60% { transform: translate(-50%, -50%) scale(1.1); }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }

    #milestone-banner .banner-text {
      font-size: clamp(14px, 4.5vw, 28px);
      color: #f0c040;
      text-shadow:
        -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000,
        0 -2px 0 #000, 0 2px 0 #000, -2px 0 0 #000, 2px 0 0 #000,
        0 0 24px rgba(0,0,0,0.8), 0 0 48px rgba(0,0,0,0.4),
        0 0 20px rgba(240,192,64,0.5);
      line-height: 1.6;
      white-space: pre-line;
      word-wrap: break-word;
    }

    /* Milestone dialog — big centered "press any key" overlay */
    #milestone-dialog {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(10, 10, 26, 0.85);
      z-index: 30;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 40px 24px;
    }
    #milestone-dialog.visible {
      display: flex;
      animation: fadeIn 0.5s ease;
    }
    #milestone-dialog .md-title {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(16px, 4vw, 32px);
      color: #f0c040;
      text-shadow:
        3px 3px 0 #000,
        0 0 30px rgba(240,192,64,0.5);
      margin-bottom: 24px;
      white-space: pre-line;
      line-height: 1.8;
    }
    #milestone-dialog .md-desc {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(8px, 2vw, 13px);
      color: #c0c0d0;
      text-shadow: 1px 1px 0 #000;
      margin-bottom: 40px;
      line-height: 2.2;
      max-width: 600px;
      white-space: pre-line;
    }
    #milestone-dialog .md-prompt {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(7px, 1.5vw, 11px);
      color: #808090;
      animation: blink 1.2s step-start infinite;
    }
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    /* Dragon slaying screen */
    #dragon-screen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.9);
      z-index: 30;
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }

    #dragon-screen.visible {
      display: flex;
      animation: fadeIn 1s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    #dragon-screen canvas {
      margin-bottom: 20px;
    }

    /* Controls hint */
    #controls-hint {
      position: absolute;
      bottom: 16px;
      right: 24px;
      font-size: 12px;
      color: #ffffff;
      text-shadow: 1px 1px 0 #000;
      z-index: 10;
      pointer-events: none;
      line-height: 2.2;
      text-align: right;
    }
    #controls-hint .control-line { display: block; }

    /* Minimap — hidden by default */
    #minimap {
      display: none;
      position: absolute;
      top: 80px;
      right: 20px;
      border: 3px solid #f0c040;
      z-index: 10;
      background: rgba(0,0,0,0.7);
      image-rendering: pixelated;
    }

    /* Title screen */
    #title-screen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(10, 10, 26, 0.92);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 50;
      cursor: pointer;
    }

    /* Loading screen */
    #loading {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #0a0a1a;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }

    #loading .load-title {
      font-size: 32px;
      color: #f0c040;
      margin-bottom: 32px;
      text-shadow: 3px 3px 0 #000;
    }

    #loading .load-bar-outer {
      width: 400px;
      height: 24px;
      border: 3px solid #f0c040;
      background: #1a1a2a;
    }

    #loading .load-bar-inner {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #d4a020 0%, #f0c040 50%, #f0d060 100%);
      background-size: 200% 100%;
      transition: width 0.3s;
      animation: loadBarShimmer 1.5s ease-in-out infinite;
    }

    @keyframes loadBarShimmer {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.85; }
    }

    #loading .load-text {
      font-size: 14px;
      color: #808090;
      margin-top: 16px;
      animation: loadTextPulse 0.8s ease-in-out infinite;
    }

    @keyframes loadTextPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* Interaction prompt above items */
    .interact-prompt {
      position: absolute;
      font-size: 14px;
      color: #f0c040;
      text-shadow: 1px 1px 0 #000;
      pointer-events: none;
      z-index: 5;
      animation: bobUpDown 1s ease-in-out infinite;
    }

    @keyframes bobUpDown {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-4px); }
    }

    /* Mobile hint hidden by default, desktop hint shown */
    .mobile-hint { display: none; }
    .desktop-hint { display: inline; }

    /* Touch devices — swap hints based on pointer capability */
    @media (pointer: coarse) {
      .mobile-hint { display: inline; }
      .desktop-hint { display: none; }
    }

    /* ============================================================
       RESPONSIVE — Tablets & smaller (≤768px)
       ============================================================ */
    @media (max-width: 768px) {
      .mobile-hint { display: inline; }
      .desktop-hint { display: none; }

      #hud {
        padding: 10px 12px;
      }
      #hud .title {
        font-size: 12px;
        letter-spacing: 1px;
      }
      #hud .subtitle {
        font-size: 8px;
        margin-top: 3px;
      }
      #hud .quest-info {
        font-size: 8px;
      }

      #minimap {
        width: 120px !important;
        height: 90px !important;
        top: 56px;
        right: 8px;
      }

      #info-panel {
        max-width: 95%;
        padding: 16px 18px;
        bottom: calc(72px + env(safe-area-inset-bottom, 0px));
        border-width: 3px;
      }
      #info-panel .panel-status {
        font-size: 8px;
        margin-bottom: 6px;
      }
      #info-panel .panel-title {
        font-size: 9px;
        margin-bottom: 10px;
        line-height: 1.5;
      }
      #info-panel .panel-desc {
        font-size: 8px;
        line-height: 1.9;
      }
      #info-panel .panel-number {
        font-size: 8px;
        padding: 3px 8px;
        margin-right: 8px;
      }
      #info-panel .panel-explore {
        font-size: 9px;
        padding: 8px 18px;
      }

      #controls-hint {
        font-size: 8px;
        bottom: 10px;
        right: 12px;
      }

      #milestone-banner .banner-text {
        font-size: clamp(12px, 3.5vw, 18px);
        line-height: 1.6;
      }

      /* Loading screen */
      #loading .load-title {
        font-size: 20px;
        margin-bottom: 20px;
      }
      #loading .load-bar-outer {
        width: 70vw;
        max-width: 300px;
        height: 18px;
      }
      #loading .load-text {
        font-size: 10px;
        margin-top: 12px;
      }
    }

    /* ============================================================
       RESPONSIVE — Small phones (≤480px)
       ============================================================ */
    @media (max-width: 480px) {
      #hud {
        padding: 8px 8px;
        flex-direction: column;
        align-items: flex-start;
        gap: 2px;
      }
      #hud .title {
        font-size: 10px;
      }
      #hud .subtitle {
        display: none;
      }
      #hud .quest-info {
        font-size: 7px;
        text-align: left;
      }

      #minimap {
        width: 90px !important;
        height: 68px !important;
        top: 50px;
        right: 6px;
        border-width: 2px;
      }

      #info-panel {
        padding: 12px 14px;
        bottom: calc(92px + env(safe-area-inset-bottom, 0px));
        border-width: 2px;
      }
      #info-panel .panel-title {
        font-size: 8px;
        line-height: 1.5;
        margin-bottom: 8px;
      }
      #info-panel .panel-desc {
        font-size: 7px;
        line-height: 1.9;
      }
      #info-panel .panel-explore {
        font-size: 8px;
        padding: 8px 16px;
      }

      #milestone-banner .banner-text {
        font-size: clamp(10px, 3vw, 14px);
        line-height: 1.5;
      }

      #controls-hint {
        font-size: 7px;
        bottom: 6px;
        right: 8px;
      }

      /* Title screen */
      #title-screen {
        padding: 16px;
      }
    }

    /* ============================================================
       NEW UI ELEMENTS
       ============================================================ */

    /* Intro backdrop — dim background when modal is shown */
    #intro-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 49;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    #intro-backdrop.visible {
      opacity: 1;
      pointer-events: all;
    }

    /* Intro scroll — medieval parchment style, pixel font */
    #intro-scroll {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 50;
      background: linear-gradient(180deg, #efe6d4 0%, #d9ccb8 100%);
      border: 4px solid #4a3520;
      border-radius: 4px;
      padding: 36px 44px;
      max-width: 560px;
      width: 90%;
      text-align: center;
      box-shadow: 
        0 0 0 2px #6b5344,
        0 12px 32px rgba(0,0,0,0.4),
        inset 0 1px 0 rgba(255,255,255,0.3);
      display: none;
    }
    #intro-scroll.visible {
      display: block;
      animation: panelSlideUp 0.4s ease-out;
    }
    #intro-scroll .scroll-title {
      font-family: 'Press Start 2P', monospace;
      font-size: 18px;
      color: #2a1f14;
      text-shadow: 1px 1px 0 rgba(255,255,255,0.5);
      margin-bottom: 24px;
      line-height: 2.2;
    }
    #intro-scroll .scroll-text {
      font-family: 'Silkscreen', sans-serif;
      font-size: 14px;
      color: #3d3528;
      text-shadow: 0 1px 0 rgba(255,255,255,0.4);
      line-height: 1.9;
      margin-bottom: 28px;
    }
    #intro-scroll .scroll-paragraph {
      text-wrap: balance;
      margin-bottom: 0.8em;
    }
    #intro-scroll .scroll-paragraph:last-child {
      margin-bottom: 0;
    }
    #intro-scroll .go-btn {
      display: inline-block;
      font-family: 'Press Start 2P', monospace;
      font-size: 14px;
      color: #efe6d4;
      background: linear-gradient(180deg, #6b5344 0%, #4a3520 100%);
      border: 2px solid #2a1f14;
      border-radius: 2px;
      padding: 14px 36px;
      cursor: pointer;
      text-shadow: none;
      animation: bobUpDown 1.5s ease-in-out infinite;
      transition: all 0.2s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.1);
    }
    #intro-scroll .go-btn:hover {
      background: linear-gradient(180deg, #7b6354 0%, #5a4530 100%);
      color: #fff;
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
    }

    /* Panel explore button — medieval style */
    #info-panel .panel-explore {
      display: inline-block;
      font-family: 'Press Start 2P', monospace;
      font-size: 9px;
      color: #efe6d4;
      background: linear-gradient(180deg, #6b5344 0%, #4a3520 100%);
      padding: 10px 22px;
      text-decoration: none;
      cursor: pointer;
      transition: all 0.2s;
      border: 2px solid #2a1f14;
      border-radius: 2px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.1);
    }
    #info-panel .panel-explore:hover {
      background: linear-gradient(180deg, #7b6354 0%, #5a4530 100%);
      color: #fff;
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
    }
    #info-panel .panel-explore.hidden {
      display: none;
    }

    /* Slay button */
    #slay-button {
      position: absolute;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 25;
      display: none;
    }
    #slay-button.visible {
      display: block;
      animation: milestonePulse 0.5s ease-out;
    }
    #slay-button button {
      font-family: 'Press Start 2P', monospace;
      font-size: 20px;
      color: #fff;
      background: linear-gradient(180deg, #c03030 0%, #801818 100%);
      border: 4px solid #f04040;
      padding: 16px 48px;
      cursor: pointer;
      text-shadow: 2px 2px 0 #000;
      box-shadow: 0 0 30px rgba(255,60,60,0.4);
      animation: bobUpDown 1s ease-in-out infinite;
      transition: background 0.2s;
    }
    #slay-button button:hover {
      background: linear-gradient(180deg, #e04040 0%, #a02020 100%);
    }

    /* Victory screen */
    #victory-screen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(10, 10, 26, 0.88);
      z-index: 50;
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      text-align: center;
      padding: 24px;
    }
    #victory-screen.visible {
      display: flex;
      animation: fadeIn 1s ease;
    }
    #victory-screen .victory-title {
      font-size: clamp(20px, 5vw, 40px);
      color: #f0c040;
      text-shadow: 3px 3px 0 #000, 0 0 40px rgba(240,192,64,0.4);
      margin-bottom: 24px;
    }
    #victory-screen .victory-text {
      font-size: clamp(8px, 2vw, 14px);
      color: #c0c0d0;
      text-shadow: 1px 1px 0 #000;
      line-height: 2.4;
      margin-bottom: 32px;
      max-width: 600px;
    }
    #victory-screen .cta-btn {
      display: inline-block;
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(10px, 2.5vw, 16px);
      color: #0a0a1a;
      background: #f0c040;
      padding: 14px 32px;
      text-decoration: none;
      cursor: pointer;
      margin-bottom: 16px;
      transition: background 0.2s;
    }
    #victory-screen .cta-btn:hover {
      background: #ffe070;
    }
    #victory-screen .secondary-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(8px, 1.5vw, 12px);
      color: #f0c040;
      background: none;
      border: 2px solid #f0c040;
      padding: 10px 24px;
      cursor: pointer;
      transition: background 0.2s;
    }
    #victory-screen .secondary-btn:hover {
      background: rgba(240,192,64,0.15);
    }

    /* Roadmap summary overlay */
    #roadmap-overlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(10, 10, 26, 0.92);
      z-index: 45;
      display: none;
      justify-content: center;
      align-items: flex-start;
      overflow-y: auto;
      padding: 40px 24px;
    }
    #roadmap-overlay.visible {
      display: flex;
      animation: fadeIn 0.4s ease;
    }
    #roadmap-overlay .roadmap-scroll {
      background: linear-gradient(135deg, #2a1a08 0%, #3a2510 40%, #2a1a08 100%);
      border: 4px solid #c09030;
      border-radius: 8px;
      padding: 32px;
      max-width: 700px;
      width: 100%;
      box-shadow: 0 0 60px rgba(192,144,48,0.3), inset 0 0 30px rgba(0,0,0,0.5);
    }
    #roadmap-overlay .roadmap-title {
      font-size: 18px;
      color: #f0c040;
      text-shadow: 2px 2px 0 #000;
      text-align: center;
      margin-bottom: 28px;
    }
    #roadmap-overlay .roadmap-close {
      position: absolute;
      top: 50px;
      right: 40px;
      font-family: 'Press Start 2P', monospace;
      font-size: 16px;
      color: #f0c040;
      background: none;
      border: none;
      cursor: pointer;
      z-index: 46;
    }
    #roadmap-overlay .roadmap-item {
      padding: 16px 0;
      border-bottom: 1px solid rgba(192,144,48,0.2);
    }
    #roadmap-overlay .roadmap-item:last-child {
      border-bottom: none;
    }
    #roadmap-overlay .ri-status {
      font-size: 10px;
      margin-bottom: 6px;
    }
    #roadmap-overlay .ri-status.shipped { color: #80d080; }
    #roadmap-overlay .ri-status.upcoming { color: #f0c040; }
    #roadmap-overlay .ri-status.pitfall { color: #ff8080; }
    #roadmap-overlay .ri-title {
      font-size: 12px;
      color: #fff;
      text-shadow: 1px 1px 0 #000;
      margin-bottom: 8px;
    }
    #roadmap-overlay .roadmap-section-title {
      margin-top: 28px;
      font-size: 12px;
      color: #f0c040;
      text-shadow: 1px 1px 0 #000;
      letter-spacing: 1px;
    }
    #roadmap-overlay .roadmap-section-title:first-of-type {
      margin-top: 0;
    }
    #roadmap-overlay .ri-desc {
      font-size: 9px;
      color: #a0a0b0;
      line-height: 2;
    }
    #roadmap-overlay .ri-label {
      color: #f0c040;
    }
    #roadmap-overlay .ri-link {
      display: inline-block;
      font-family: 'Press Start 2P', monospace;
      font-size: 8px;
      color: #f0c040;
      margin-top: 8px;
      text-decoration: none;
    }
    #roadmap-overlay .ri-link:hover {
      color: #ffe070;
    }

    /* Mute button */
    #mute-btn {
      position: absolute;
      bottom: 20px;
      left: 20px;
      z-index: 10;
      font-family: 'Press Start 2P', monospace;
      font-size: 14px;
      width: 44px;
      height: 44px;
      min-width: 44px;
      min-height: 44px;
      background: rgba(0,0,0,0.6);
      color: #f0c040;
      border: 2px solid #f0c040;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
    }
    #mute-btn:hover {
      background: rgba(240,192,64,0.2);
    }
    #mute-btn.muted {
      color: #806020;
      border-color: #806020;
    }

    /* Roadmap HUD button */
    #roadmap-btn {
      position: absolute;
      top: 80px;
      left: 20px;
      z-index: 10;
      font-family: 'Press Start 2P', monospace;
      font-size: 8px;
      color: #f0c040;
      background: rgba(0,0,0,0.6);
      border: 2px solid #f0c040;
      padding: 12px 16px;
      min-width: 44px;
      min-height: 44px;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    #roadmap-btn:hover {
      background: rgba(240,192,64,0.2);
    }

    /* Mobile banner */
    #mobile-banner {
      position: absolute;
      top: 0; left: 0; right: 0;
      background: rgba(240,192,64,0.95);
      z-index: 100;
      padding: 12px 16px;
      text-align: center;
      display: none;
    }
    #mobile-banner .mb-text {
      font-size: 8px;
      color: #0a0a1a;
      line-height: 2;
    }
    #mobile-banner .mb-close {
      font-family: 'Press Start 2P', monospace;
      font-size: 8px;
      color: #0a0a1a;
      background: none;
      border: 1px solid #0a0a1a;
      padding: 4px 8px;
      margin-top: 8px;
      cursor: pointer;
    }

    /* Dragon speech bubble (canvas overlay during opening) */
    #dragon-speech {
      position: absolute;
      z-index: 50;
      display: none;
      pointer-events: none;
    }
    #dragon-speech.visible {
      display: block;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game-canvas"></canvas>
    <canvas id="minimap" width="200" height="150"></canvas>

    <div id="hud">
      <div>
        <div class="title">DICTATION QUEST</div>
        <div class="subtitle">The Quest for Clinical Dictation</div>
      </div>
      <div class="quest-info">
        <div id="quest-status">QUEST: Slay the Dragon</div>
        <div id="quest-progress" style="margin-top:4px;"></div>
        <div id="coin-counter" style="margin-top:4px; color:#f0d060;"></div>
      </div>
    </div>

    <div id="info-panel">
      <div class="panel-status" id="panel-status"></div>
      <div class="panel-title" id="panel-title"></div>
      <div class="panel-desc" id="panel-desc"></div>
      <div class="panel-actions">
        <a class="panel-explore hidden" id="panel-explore" target="_blank">Explore Docs</a>
      </div>
    </div>

    <div id="milestone-banner">
      <div class="banner-text" id="banner-text"></div>
    </div>

    <!-- Milestone dialog — big centered overlay -->
    <div id="milestone-dialog">
      <div class="md-title" id="md-title"></div>
      <div class="md-desc" id="md-desc"></div>
      <div class="md-prompt"><span class="desktop-hint">Press any key to continue</span><span class="mobile-hint">Tap to continue</span></div>
    </div>

    <div id="controls-hint">
      <span class="desktop-hint">Arrow Keys — Move (Path Only)</span>
      <span class="mobile-hint">Tap to Move (Path Only)</span>
    </div>

    <!-- Intro scroll (replaces title screen) -->
    <div id="intro-backdrop"></div>
    <div id="intro-scroll">
      <div class="scroll-title">DICTATION QUEST</div>
      <div class="scroll-text">
        <p class="scroll-paragraph">Follow Bard the Bowman on his journey through the Corti API to slay the Dragon.</p>
        <p class="scroll-paragraph"><span class="desktop-hint">Use <span style="color:#4a3520;">Arrow Keys</span> to move.</span><span class="mobile-hint"><span style="color:#4a3520;">Tap</span> to move.</span> Stay on the road and walk into landmarks to discover them.</p>
      </div>
      <button class="go-btn" id="go-btn">GO</button>
    </div>

    <!-- Slay dragon button -->
    <div id="slay-button">
      <button id="slay-btn">SLAY THE DRAGON</button>
    </div>

    <!-- Victory screen -->
    <div id="victory-screen">
      <div class="victory-title">QUEST COMPLETE</div>
      <div class="victory-text">
        Bard has slain the Dragon.<br>The Corti API roadmap awaits.
      </div>
      <a class="cta-btn" href="https://console.corti.app/signup" target="_blank" id="studio-cta">Start Building in Corti Console</a>
      <button class="secondary-btn" id="review-roadmap-btn">Review the Roadmap</button>
      <button class="secondary-btn" id="play-again-btn">Play Again</button>
    </div>

    <!-- Roadmap summary overlay -->
    <div id="roadmap-overlay">
      <button class="roadmap-close" id="roadmap-close">X</button>
      <div class="roadmap-scroll" id="roadmap-scroll-content"></div>
    </div>

    <!-- Mute toggle -->
    <button id="mute-btn" title="Toggle audio">♪</button>

    <!-- Roadmap HUD button -->
    <button id="roadmap-btn">VIEW ROADMAP</button>

    <!-- Mobile banner -->
    <div id="mobile-banner">
      <div class="mb-text">This experience is optimized for desktop.<br>For the best experience, visit on a computer.</div>
      <button class="mb-close" id="mobile-close">GOT IT</button>
    </div>

    <div id="loading">
      <div class="load-title">DICTATION QUEST</div>
      <div class="load-bar-outer">
        <div class="load-bar-inner" id="load-bar"></div>
      </div>
      <div class="load-text" id="load-text">Generating world...</div>
    </div>
  </div>

  <script>
// ============================================================
// DICTATION QUEST — 2D Pixel Art Roadmap Quest
// ============================================================

const TILE_SIZE = 32;
const MAP_COLS = 40;
const MAP_ROWS = 35;
const CAMERA_SMOOTH = 0.1;
const DEFAULT_ZOOM = 2; // mutable zoom, initial value

// Directions: 0=N, 1=NE, 2=E, 3=SE, 4=S, 5=SW, 6=W, 7=NW
const DIR_NAMES = ['n','ne','e','se','s','sw','w','nw'];
const DIR_OFFSETS = [
  [0,-1],[1,-1],[1,0],[1,1],[0,1],[-1,1],[-1,0],[-1,-1]
];

// ============================================================
// ROADMAP DATA
// ============================================================
// Winding adventure path layout:
// Start(4,10) → East to item1(16,10) → East to item2(30,10) → South to item3(30,24)
// → East to milestone1(44,24) → North to item4(44,12) → East to item5(58,12)
// → South to item6(58,30) → West to item7(44,30) → South to dragon(44,44)
const ROADMAP_ITEMS = [
  {
    id: 1,
    title: 'Clinical-grade STT Models',
    status: 'shipped',
    description: 'Foundation. High-accuracy medical STT across supported languages, purpose-built for clinical terminology and high-stakes workflows.',
    mapX: 9, mapY: 8,
    icon: 'tower',
    docsUrl: 'https://docs.corti.ai/about/languages'
  },
  {
    id: 2,
    title: 'Command Framework',
    status: 'shipped',
    description: 'Define voice commands with dynamic parameters to navigate, edit, and control application workflows. Gives clinicians precise control without breaking dictation flow.',
    mapX: 15, mapY: 8,
    icon: 'tower',
    docsUrl: 'https://docs.corti.ai/stt/commands'
  },
  {
    id: 3,
    title: 'Output Formatting',
    status: 'shipped',
    description: 'Configurable formatting for dates, times, numbers, units, measurements, ranges, and ordinals. Automatic capitalization and punctuation. Output reads like a clinical document, not a raw transcript.',
    mapX: 21, mapY: 8,
    icon: 'tower',
    docsUrl: 'https://docs.corti.ai/stt/formatting'
  },
  {
    id: 'milestone1',
    title: 'EMPOWERED TO BUILD\nA DRAGON REPLACEMENT',
    status: 'milestone',
    description: '',
    mapX: 27, mapY: 8,
    icon: 'bow'
  },
  {
    id: 4,
    title: 'Advanced Formatting',
    status: 'upcoming',
    description: 'Improved handling of key homophones (e.g., "period", "colon"). Better date and number localization.',
    mapX: 27, mapY: 15,
    icon: 'tent'
  },
  {
    id: 5,
    title: 'Advanced Speed',
    status: 'upcoming',
    description: 'Real-time partial transcription as the user speaks. Essential for building responsive dictation UIs where text appears on screen with minimal perceived latency.',
    mapX: 21, mapY: 15,
    icon: 'tent'
  },
  {
    id: 6,
    title: 'Advanced Commands',
    status: 'upcoming',
    description: 'Wildcard variables for templated command systems beyond static phrase matching. Non-verbal command anchors that map physical device inputs (foot pedals, hotkeys, button presses) to actions in the transcription stream.',
    mapX: 15, mapY: 15,
    icon: 'tent'
  },
  {
    id: 7,
    title: 'Advanced Customization',
    status: 'upcoming',
    description: 'Organization-specific tuning. Custom vocabulary handles recognition (getting the model to hear the right terms), replacement rules handle formatting (standardizing what appears in output). Together they let customers tailor the full pipeline to their environment.',
    mapX: 9, mapY: 15,
    icon: 'tent'
  },
  {
    id: 'milestone2',
    title: 'SLAY THE DRAGON\nONCE AND FOR ALL',
    status: 'milestone',
    description: '',
    mapX: 9, mapY: 24,
    icon: 'dragon'
  }
];

const PITFALLS = [
  {
    id: 'P1',
    title: 'HIPAA / PHI COMPLIANCE GAPS',
    risk: 'Patient identifiers can leak through raw audio retention, debug logs, or broad internal access.',
    mitigation: 'Use policy controls for retention, encryption, least-privilege access, and auditable PHI-safe operations.',
    mapX: 24, mapY: 8
  },
  {
    id: 'P2',
    title: 'LANGUAGE HANDLING BLIND SPOTS',
    risk: 'Generic STT can miss clinical terms across accents, dialects, and locale-specific vocabulary.',
    mitigation: 'Use multilingual clinical models, locale-specific evaluation, and custom vocabulary per organization.',
    mapX: 27, mapY: 11
  },
  {
    id: 'P3',
    title: 'FORMATTING SAFETY FAILURES',
    risk: 'Dates, units, dosages, and punctuation can be formatted incorrectly and alter clinical meaning.',
    mitigation: 'Apply deterministic formatting rules with QA checks for numbers, units, punctuation, and date handling.',
    mapX: 18, mapY: 15
  },
  {
    id: 'P4',
    title: 'COMMAND + LATENCY BREAKDOWNS',
    risk: 'False command triggers and slow transcription can interrupt clinician workflow and reduce trust.',
    mitigation: 'Use robust command parsing, non-verbal triggers, and low-latency streaming partial transcription.',
    mapX: 9, mapY: 20
  }
];

// ============================================================
// PIXEL ART GENERATOR — All sprites generated procedurally
// ============================================================

class PixelArt {
  static createCanvas(w, h) {
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    return { canvas: c, ctx: c.getContext('2d') };
  }

  // Draw a single pixel (scaled)
  static px(ctx, x, y, color, scale = 1) {
    ctx.fillStyle = color;
    ctx.fillRect(x * scale, y * scale, scale, scale);
  }

  // Load character sprites from PixelLab-generated PNGs
  // Returns a promise that resolves to {idle: {dir: Image}, walk: {dir: [Image]}}
  static async loadCharacterSprites() {
    const PIXELLAB_DIR_MAP = {
      'n': 'north',
      'ne': 'north-east',
      'e': 'east',
      'se': 'south-east',
      's': 'south',
      'sw': 'south-west',
      'w': 'west',
      'nw': 'north-west'
    };
    const WALK_FRAMES = 6;
    const basePath = 'assets/character';

    const loadImg = (src) => new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error('Failed to load: ' + src));
      img.src = src;
    });

    const sprites = {};
    const promises = [];

    for (const dir of DIR_NAMES) {
      const plDir = PIXELLAB_DIR_MAP[dir];
      sprites[dir] = [];

      // Load walk animation frames (6 frames)
      for (let f = 0; f < WALK_FRAMES; f++) {
        const frameStr = String(f).padStart(3, '0');
        const path = `${basePath}/animations/walking-4-frames/${plDir}/frame_${frameStr}.png`;
        const idx = f;
        const d = dir;
        promises.push(
          loadImg(path).then(img => { sprites[d][idx] = img; })
        );
      }
    }

    await Promise.all(promises);

    // Also load idle frames (rotation images) as the stand-still pose
    const idleSprites = {};
    const idlePromises = [];
    for (const dir of DIR_NAMES) {
      const plDir = PIXELLAB_DIR_MAP[dir];
      const path = `${basePath}/rotations/${plDir}.png`;
      idlePromises.push(
        loadImg(path).then(img => { idleSprites[dir] = img; })
      );
    }
    await Promise.all(idlePromises);

    return { walk: sprites, idle: idleSprites };
  }

  // Load a Wang tileset from PixelLab-generated PNG + metadata JSON
  // Returns an array of 16 tile canvases indexed by Wang number (NW*8+NE*4+SW*2+SE)
  // Darken a canvas by overlaying semi-transparent black (source-atop preserves transparency)
  static darkenCanvas(canvas, amount = 0.2) {
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = `rgba(0, 0, 0, ${amount})`;
    ctx.globalCompositeOperation = 'source-atop';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.globalCompositeOperation = 'source-over';
    return canvas;
  }

  static async loadWangTileset(pngPath, metaPath) {
    // Load image
    const img = await new Promise((resolve, reject) => {
      const i = new Image();
      i.onload = () => resolve(i);
      i.onerror = () => reject(new Error('Failed to load tileset: ' + pngPath));
      i.src = pngPath;
    });

    // Load metadata
    const resp = await fetch(metaPath);
    const meta = await resp.json();

    // Parse tiles and index by Wang number
    const wangTiles = new Array(16).fill(null);
    for (const tile of meta.tileset_data.tiles) {
      const c = tile.corners;
      const nw = c.NW === 'upper' ? 1 : 0;
      const ne = c.NE === 'upper' ? 1 : 0;
      const sw = c.SW === 'upper' ? 1 : 0;
      const se = c.SE === 'upper' ? 1 : 0;
      const wangIdx = nw * 8 + ne * 4 + sw * 2 + se;

      // Extract tile from spritesheet
      const bb = tile.bounding_box;
      const canvas = document.createElement('canvas');
      canvas.width = bb.width;
      canvas.height = bb.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, bb.x, bb.y, bb.width, bb.height, 0, 0, bb.width, bb.height);
      wangTiles[wangIdx] = canvas;
    }
    return wangTiles;
  }

  // Generate tile sprites
  static generateTiles() {
    const tiles = {};
    const S = TILE_SIZE;

    // Grass tile (several variants)
    for (let v = 0; v < 4; v++) {
      const { canvas, ctx } = this.createCanvas(S, S);
      const base = ['#3a7a3a','#2d6b2d','#358035','#2f722f'][v];
      ctx.fillStyle = base;
      ctx.fillRect(0, 0, S, S);
      // Random grass details
      const rng = this.seededRandom(v * 1000);
      for (let i = 0; i < 8; i++) {
        const gx = Math.floor(rng() * S);
        const gy = Math.floor(rng() * S);
        ctx.fillStyle = rng() > 0.5 ? '#4a8a4a' : '#2a6a2a';
        ctx.fillRect(gx, gy, 2, 2);
      }
      tiles[`grass${v}`] = canvas;
    }

    // Path tile
    for (let v = 0; v < 2; v++) {
      const { canvas, ctx } = this.createCanvas(S, S);
      ctx.fillStyle = v === 0 ? '#a89060' : '#9a8555';
      ctx.fillRect(0, 0, S, S);
      const rng = this.seededRandom(v * 2000);
      for (let i = 0; i < 6; i++) {
        ctx.fillStyle = rng() > 0.5 ? '#b8a070' : '#908050';
        ctx.fillRect(Math.floor(rng()*S), Math.floor(rng()*S), 3, 2);
      }
      tiles[`path${v}`] = canvas;
    }

    // Water tile
    const { canvas: waterC, ctx: waterCtx } = this.createCanvas(S, S);
    waterCtx.fillStyle = '#2050a0';
    waterCtx.fillRect(0, 0, S, S);
    for (let i = 0; i < 4; i++) {
      waterCtx.fillStyle = '#3060b0';
      waterCtx.fillRect(i*8, 4 + (i%2)*4, 6, 2);
    }
    tiles.water = waterC;

    // Dark grass / forest floor
    const { canvas: darkG, ctx: darkGCtx } = this.createCanvas(S, S);
    darkGCtx.fillStyle = '#1a4a1a';
    darkGCtx.fillRect(0, 0, S, S);
    for (let i = 0; i < 6; i++) {
      darkGCtx.fillStyle = i%2===0 ? '#0d3d0d' : '#225522';
      darkGCtx.fillRect(Math.floor(Math.random()*S), Math.floor(Math.random()*S), 3, 2);
    }
    tiles.darkGrass = darkG;

    // Stone tile
    const { canvas: stoneC, ctx: stoneCtx } = this.createCanvas(S, S);
    stoneCtx.fillStyle = '#606070';
    stoneCtx.fillRect(0, 0, S, S);
    stoneCtx.fillStyle = '#50505f';
    stoneCtx.fillRect(0, 0, 15, 15);
    stoneCtx.fillRect(17, 17, 15, 15);
    stoneCtx.fillStyle = '#707080';
    stoneCtx.fillRect(17, 0, 15, 15);
    stoneCtx.fillRect(0, 17, 15, 15);
    stoneCtx.fillStyle = '#555565';
    stoneCtx.fillRect(0, 16, 32, 1);
    stoneCtx.fillRect(16, 0, 1, 32);
    tiles.stone = stoneC;

    // Volcanic / dragon lair tile
    const { canvas: volc, ctx: volcCtx } = this.createCanvas(S, S);
    volcCtx.fillStyle = '#2a1515';
    volcCtx.fillRect(0, 0, S, S);
    for (let i = 0; i < 5; i++) {
      volcCtx.fillStyle = ['#3a1a1a','#4a2020','#1a0a0a'][i%3];
      volcCtx.fillRect(Math.floor(Math.random()*S), Math.floor(Math.random()*S), 4, 3);
    }
    tiles.volcanic = volc;

    return tiles;
  }

  // Decorative sprites
  static generateDecorations() {
    const decos = {};
    const S = TILE_SIZE;

    // Tree (pine) — wider, more substantial
    const drawTree = (variant) => {
      const { canvas, ctx } = this.createCanvas(S, S*2);
      const trunk = variant === 0 ? '#5a3a20' : '#4a3018';
      const trunkDk = variant === 0 ? '#3a2a15' : '#342010';
      const leaves = variant === 0 ? '#1a5a1a' : '#0d4d0d';
      const leavesDk = variant === 0 ? '#104010' : '#083808';
      const leavesLt = variant === 0 ? '#2a7a2a' : '#1a6a1a';
      // Shadow on ground
      ctx.fillStyle = 'rgba(0,0,0,0.15)';
      ctx.fillRect(6, S+18, 20, 6);
      // Trunk
      ctx.fillStyle = trunk;
      ctx.fillRect(13, S, 6, S-4);
      ctx.fillStyle = trunkDk;
      ctx.fillRect(13, S, 2, S-4);
      // Foliage layers (wider triangular shape)
      const layerData = [
        { y: 4, w: 26 },
        { y: 12, w: 22 },
        { y: 20, w: 18 },
        { y: 28, w: 14 },
      ];
      for (const layer of layerData) {
        const x = (S - layer.w) / 2;
        ctx.fillStyle = leavesDk;
        ctx.fillRect(x, layer.y, layer.w, 12);
        ctx.fillStyle = leaves;
        ctx.fillRect(x+1, layer.y, layer.w-2, 10);
        ctx.fillStyle = leavesLt;
        ctx.fillRect(x+3, layer.y+1, layer.w-6, 4);
      }
      // Top point
      ctx.fillStyle = leavesLt;
      ctx.fillRect(14, 1, 4, 5);
      ctx.fillRect(15, 0, 2, 3);
      return canvas;
    };
    decos.tree0 = drawTree(0);
    decos.tree1 = drawTree(1);

    // Castle tower
    const { canvas: towerC, ctx: tCtx } = this.createCanvas(S*2, S*2);
    // Base
    tCtx.fillStyle = '#808090';
    tCtx.fillRect(8, 20, 48, 44);
    tCtx.fillStyle = '#707080';
    tCtx.fillRect(12, 24, 40, 36);
    // Battlements
    tCtx.fillStyle = '#909098';
    for (let i = 0; i < 6; i++) {
      tCtx.fillRect(8 + i*9, 14, 6, 8);
    }
    // Door
    tCtx.fillStyle = '#4a3020';
    tCtx.fillRect(24, 44, 16, 20);
    tCtx.fillStyle = '#3a2010';
    tCtx.fillRect(26, 46, 12, 18);
    // Window
    tCtx.fillStyle = '#f0d060';
    tCtx.fillRect(22, 30, 6, 6);
    tCtx.fillRect(36, 30, 6, 6);
    // Flag
    tCtx.fillStyle = '#333';
    tCtx.fillRect(30, 2, 2, 14);
    tCtx.fillStyle = '#f0c040';
    tCtx.fillRect(32, 2, 10, 7);
    tCtx.fillStyle = '#d0a030';
    tCtx.fillRect(32, 5, 10, 4);
    decos.tower = towerC;

    // Treasure chest (power-up)
    const { canvas: chestC, ctx: cCtx } = this.createCanvas(S, S);
    cCtx.fillStyle = '#8a6020';
    cCtx.fillRect(6, 12, 20, 14);
    cCtx.fillStyle = '#a07030';
    cCtx.fillRect(8, 8, 16, 6);
    cCtx.fillStyle = '#f0c040';
    cCtx.fillRect(10, 10, 12, 2);
    cCtx.fillStyle = '#f0c040';
    cCtx.fillRect(14, 16, 4, 4);
    // Glow
    cCtx.fillStyle = 'rgba(240,192,64,0.3)';
    cCtx.fillRect(4, 6, 24, 22);
    decos.chest = chestC;

    // Flag / milestone marker
    const { canvas: flagC, ctx: fCtx } = this.createCanvas(S, S*2);
    fCtx.fillStyle = '#555';
    fCtx.fillRect(14, 8, 3, S+16);
    fCtx.fillStyle = '#f0c040';
    fCtx.fillRect(17, 8, 16, 10);
    fCtx.fillStyle = '#d0a030';
    fCtx.fillRect(17, 12, 16, 6);
    // Pennant cut
    fCtx.clearRect(30, 10, 4, 6);
    decos.flag = flagC;

    // Bow (on a stone pedestal, waiting to be picked up)
    const { canvas: bowC, ctx: bwCtx } = this.createCanvas(S, S*2);
    // Stone pedestal base — carved stone
    bwCtx.fillStyle = '#606060';
    bwCtx.fillRect(5, S+12, 22, 8);
    bwCtx.fillStyle = '#787878';
    bwCtx.fillRect(7, S+8, 18, 8);
    bwCtx.fillStyle = '#8a8a8a';
    bwCtx.fillRect(9, S+6, 14, 4);
    bwCtx.fillStyle = '#555';
    bwCtx.fillRect(7, S+14, 18, 2);
    // Pedestal highlight
    bwCtx.fillStyle = '#9a9a9a';
    bwCtx.fillRect(10, S+7, 12, 1);

    // Bow body — detailed recurve
    // Dark outline layer
    bwCtx.fillStyle = '#3a2010';
    bwCtx.fillRect(9, 2, 4, 2);
    bwCtx.fillRect(7, 4, 4, 3);
    bwCtx.fillRect(6, 7, 3, 4);
    bwCtx.fillRect(5, 11, 3, 6);
    bwCtx.fillRect(6, 17, 3, 4);
    bwCtx.fillRect(7, 21, 4, 3);
    bwCtx.fillRect(9, 24, 4, 3);
    bwCtx.fillRect(11, 27, 4, 2);

    // Main wood — warm brown
    bwCtx.fillStyle = '#9a5828';
    bwCtx.fillRect(10, 3, 2, 2);     // top recurve
    bwCtx.fillRect(8, 5, 2, 3);
    bwCtx.fillRect(7, 8, 2, 3);
    bwCtx.fillRect(6, 11, 2, 6);     // widest point
    bwCtx.fillRect(7, 17, 2, 4);
    bwCtx.fillRect(8, 21, 2, 3);
    bwCtx.fillRect(10, 24, 2, 3);
    bwCtx.fillRect(12, 27, 2, 2);    // bottom recurve

    // Wood highlight — lighter inner edge
    bwCtx.fillStyle = '#b87838';
    bwCtx.fillRect(10, 4, 1, 1);
    bwCtx.fillRect(8, 6, 1, 2);
    bwCtx.fillRect(7, 9, 1, 2);
    bwCtx.fillRect(6, 13, 1, 2);
    bwCtx.fillRect(7, 18, 1, 2);
    bwCtx.fillRect(9, 22, 1, 2);
    bwCtx.fillRect(11, 25, 1, 2);

    // Grip wrap — golden leather with bands
    bwCtx.fillStyle = '#d4a830';
    bwCtx.fillRect(5, 13, 3, 6);
    bwCtx.fillStyle = '#e8c040';
    bwCtx.fillRect(6, 14, 1, 4);
    // Grip detail lines
    bwCtx.fillStyle = '#b08820';
    bwCtx.fillRect(5, 14, 3, 1);
    bwCtx.fillRect(5, 16, 3, 1);

    // Nock tips — polished metal
    bwCtx.fillStyle = '#c8c8c8';
    bwCtx.fillRect(10, 2, 2, 1);
    bwCtx.fillRect(12, 28, 2, 1);
    bwCtx.fillStyle = '#e0e0e0';
    bwCtx.fillRect(11, 2, 1, 1);
    bwCtx.fillRect(13, 28, 1, 1);

    // Bowstring — thin taut line connecting nock tips
    bwCtx.fillStyle = '#e0d8c0';
    bwCtx.fillRect(13, 3, 1, 4);
    bwCtx.fillRect(13, 7, 1, 4);
    bwCtx.fillRect(13, 11, 1, 4);
    bwCtx.fillRect(13, 15, 1, 4);
    bwCtx.fillRect(13, 19, 1, 4);
    bwCtx.fillRect(13, 23, 1, 5);
    // String highlights
    bwCtx.fillStyle = '#f0ece0';
    bwCtx.fillRect(13, 13, 1, 1);
    bwCtx.fillRect(13, 17, 1, 1);

    // Arrow resting on bow
    bwCtx.fillStyle = '#b08040';
    bwCtx.fillRect(13, 15, 14, 2);
    // Arrow shaft grain
    bwCtx.fillStyle = '#c09050';
    bwCtx.fillRect(15, 15, 2, 1);
    bwCtx.fillRect(20, 15, 2, 1);
    // Arrow tip — iron
    bwCtx.fillStyle = '#707070';
    bwCtx.fillRect(25, 14, 3, 4);
    bwCtx.fillStyle = '#909090';
    bwCtx.fillRect(26, 15, 2, 2);
    bwCtx.fillStyle = '#b0b0b0';
    bwCtx.fillRect(27, 15, 1, 1);
    // Arrow fletching — red feathers
    bwCtx.fillStyle = '#cc3030';
    bwCtx.fillRect(13, 13, 3, 2);
    bwCtx.fillRect(13, 17, 3, 2);
    bwCtx.fillStyle = '#e04040';
    bwCtx.fillRect(14, 13, 1, 1);
    bwCtx.fillRect(14, 17, 1, 1);

    decos.bow = bowC;

    // Dragon
    const { canvas: dragonC, ctx: dCtx } = this.createCanvas(S*3, S*3);
    const dragonRed = '#c03030';
    const dragonDk = '#901818';
    const dragonLt = '#e04040';
    const belly = '#d0a040';
    // Body
    dCtx.fillStyle = dragonRed;
    dCtx.fillRect(24, 40, 48, 30);
    dCtx.fillStyle = dragonDk;
    dCtx.fillRect(28, 44, 40, 22);
    dCtx.fillStyle = belly;
    dCtx.fillRect(34, 48, 28, 14);
    // Head
    dCtx.fillStyle = dragonRed;
    dCtx.fillRect(60, 24, 24, 20);
    dCtx.fillStyle = dragonLt;
    dCtx.fillRect(64, 28, 16, 12);
    // Eye
    dCtx.fillStyle = '#ff0';
    dCtx.fillRect(74, 30, 6, 4);
    dCtx.fillStyle = '#000';
    dCtx.fillRect(76, 31, 3, 2);
    // Horns
    dCtx.fillStyle = '#555';
    dCtx.fillRect(66, 18, 4, 8);
    dCtx.fillRect(76, 20, 4, 6);
    // Wings
    dCtx.fillStyle = dragonDk;
    dCtx.fillRect(10, 20, 30, 24);
    dCtx.fillStyle = dragonRed;
    dCtx.fillRect(14, 24, 22, 16);
    // Wing membrane lines
    dCtx.fillStyle = dragonLt;
    dCtx.fillRect(16, 26, 2, 12);
    dCtx.fillRect(22, 24, 2, 14);
    dCtx.fillRect(28, 26, 2, 12);
    // Tail
    dCtx.fillStyle = dragonDk;
    dCtx.fillRect(8, 56, 20, 8);
    dCtx.fillRect(2, 52, 10, 8);
    dCtx.fillStyle = dragonRed;
    dCtx.fillRect(0, 50, 6, 6);
    // Legs
    dCtx.fillStyle = dragonDk;
    dCtx.fillRect(32, 68, 8, 14);
    dCtx.fillRect(54, 68, 8, 14);
    dCtx.fillRect(30, 78, 12, 6);
    dCtx.fillRect(52, 78, 12, 6);
    // Claws
    dCtx.fillStyle = '#555';
    dCtx.fillRect(30, 82, 4, 3);
    dCtx.fillRect(36, 82, 4, 3);
    dCtx.fillRect(52, 82, 4, 3);
    dCtx.fillRect(58, 82, 4, 3);
    // Mouth / fire hint
    dCtx.fillStyle = '#f08020';
    dCtx.fillRect(82, 34, 8, 4);
    dCtx.fillStyle = '#f0c040';
    dCtx.fillRect(88, 35, 4, 2);
    decos.dragon = dragonC;

    // Rocks — small pile of 3 stones with highlights and shadows
    const { canvas: rockC, ctx: rCtx } = this.createCanvas(S, S);
    // Large stone (back)
    rCtx.fillStyle = '#5a5a5a';
    rCtx.fillRect(6, 18, 14, 10);
    rCtx.fillStyle = '#6e6e6e';
    rCtx.fillRect(8, 16, 10, 10);
    rCtx.fillStyle = '#7e7e7e'; // highlight
    rCtx.fillRect(9, 17, 6, 4);
    rCtx.fillStyle = '#4a4a4a'; // shadow
    rCtx.fillRect(8, 24, 10, 3);
    // Medium stone (right)
    rCtx.fillStyle = '#626262';
    rCtx.fillRect(18, 20, 10, 8);
    rCtx.fillStyle = '#747474';
    rCtx.fillRect(19, 19, 8, 7);
    rCtx.fillStyle = '#848484'; // highlight
    rCtx.fillRect(20, 20, 4, 3);
    // Small stone (front-left)
    rCtx.fillStyle = '#6a6a6a';
    rCtx.fillRect(4, 24, 8, 6);
    rCtx.fillStyle = '#7a7a7a';
    rCtx.fillRect(5, 23, 6, 5);
    // Moss patches
    rCtx.fillStyle = '#4a6a3a';
    rCtx.fillRect(10, 18, 3, 2);
    rCtx.fillRect(21, 21, 2, 2);
    decos.rock = rockC;

    // Boulder — larger single rock with detailed shading
    const { canvas: boulderC, ctx: boCtx } = this.createCanvas(S, S);
    // Main body
    boCtx.fillStyle = '#585858';
    boCtx.fillRect(4, 12, 24, 18);
    boCtx.fillStyle = '#686868';
    boCtx.fillRect(6, 10, 20, 18);
    boCtx.fillStyle = '#7a7a7a';
    boCtx.fillRect(8, 8, 16, 16);
    // Top highlight
    boCtx.fillStyle = '#909090';
    boCtx.fillRect(10, 10, 10, 6);
    boCtx.fillStyle = '#9a9a9a';
    boCtx.fillRect(12, 11, 6, 3);
    // Bottom shadow
    boCtx.fillStyle = '#484848';
    boCtx.fillRect(6, 26, 20, 4);
    boCtx.fillStyle = '#404040';
    boCtx.fillRect(8, 28, 16, 2);
    // Cracks
    boCtx.fillStyle = '#505050';
    boCtx.fillRect(14, 14, 2, 8);
    boCtx.fillRect(10, 18, 6, 2);
    // Moss
    boCtx.fillStyle = '#4a6a3a';
    boCtx.fillRect(8, 22, 4, 3);
    boCtx.fillRect(18, 24, 3, 2);
    boCtx.fillStyle = '#5a7a4a';
    boCtx.fillRect(9, 23, 2, 2);
    decos.boulder = boulderC;

    // Flowers — cluster of colorful wildflowers with stems
    const { canvas: flowerC, ctx: flCtx } = this.createCanvas(S, S);
    // Stems
    flCtx.fillStyle = '#3a7a3a';
    flCtx.fillRect(10, 20, 2, 8);
    flCtx.fillRect(16, 18, 2, 10);
    flCtx.fillRect(22, 22, 2, 6);
    flCtx.fillStyle = '#4a8a4a';
    flCtx.fillRect(13, 22, 2, 6);
    flCtx.fillRect(19, 20, 2, 8);
    // Leaves
    flCtx.fillStyle = '#3a8a3a';
    flCtx.fillRect(8, 24, 4, 2);
    flCtx.fillRect(18, 26, 4, 2);
    flCtx.fillRect(14, 25, 3, 2);
    // Pink flower (left)
    flCtx.fillStyle = '#d04070';
    flCtx.fillRect(8, 16, 6, 6);
    flCtx.fillStyle = '#e06090';
    flCtx.fillRect(9, 17, 4, 4);
    flCtx.fillStyle = '#ffcc44';
    flCtx.fillRect(10, 18, 2, 2);
    // Yellow flower (center)
    flCtx.fillStyle = '#d0a020';
    flCtx.fillRect(14, 14, 6, 6);
    flCtx.fillStyle = '#e8c040';
    flCtx.fillRect(15, 15, 4, 4);
    flCtx.fillStyle = '#a06010';
    flCtx.fillRect(16, 16, 2, 2);
    // White/blue flower (right)
    flCtx.fillStyle = '#7090d0';
    flCtx.fillRect(20, 18, 6, 6);
    flCtx.fillStyle = '#90b0e0';
    flCtx.fillRect(21, 19, 4, 4);
    flCtx.fillStyle = '#ffdd55';
    flCtx.fillRect(22, 20, 2, 2);
    decos.flower = flowerC;

    // Rose bush — red roses on a green bush
    const { canvas: roseBushC, ctx: rbCtx } = this.createCanvas(S, S);
    // Bush body
    rbCtx.fillStyle = '#2a5a2a';
    rbCtx.fillRect(4, 14, 24, 16);
    rbCtx.fillStyle = '#3a6a3a';
    rbCtx.fillRect(6, 12, 20, 16);
    rbCtx.fillStyle = '#4a7a4a';
    rbCtx.fillRect(8, 10, 16, 14);
    // Leaf highlights
    rbCtx.fillStyle = '#5a8a4a';
    rbCtx.fillRect(10, 12, 4, 3);
    rbCtx.fillRect(18, 14, 3, 3);
    rbCtx.fillRect(12, 20, 4, 2);
    // Red roses (3 roses)
    rbCtx.fillStyle = '#c02020';
    rbCtx.fillRect(8, 12, 6, 5);
    rbCtx.fillStyle = '#e03030';
    rbCtx.fillRect(9, 13, 4, 3);
    rbCtx.fillStyle = '#c02020';
    rbCtx.fillRect(18, 10, 5, 5);
    rbCtx.fillStyle = '#e03030';
    rbCtx.fillRect(19, 11, 3, 3);
    rbCtx.fillStyle = '#c02020';
    rbCtx.fillRect(12, 18, 6, 5);
    rbCtx.fillStyle = '#e03030';
    rbCtx.fillRect(13, 19, 4, 3);
    // Rose centers
    rbCtx.fillStyle = '#ff5555';
    rbCtx.fillRect(10, 14, 2, 1);
    rbCtx.fillRect(20, 12, 1, 1);
    rbCtx.fillRect(14, 20, 2, 1);
    decos.roseBush = roseBushC;

    // Bridge section
    const { canvas: bridgeC, ctx: brCtx } = this.createCanvas(S, S);
    brCtx.fillStyle = '#6a4a30';
    brCtx.fillRect(0, 8, S, 16);
    brCtx.fillStyle = '#7a5a40';
    for (let i = 0; i < 4; i++) {
      brCtx.fillRect(i*8, 10, 6, 12);
    }
    brCtx.fillStyle = '#5a3a20';
    brCtx.fillRect(0, 8, S, 2);
    brCtx.fillRect(0, 22, S, 2);
    decos.bridge = bridgeC;

    // Campfire
    const { canvas: fireC, ctx: fiCtx } = this.createCanvas(S, S);
    fiCtx.fillStyle = '#5a3a20';
    fiCtx.fillRect(8, 22, 16, 6);
    fiCtx.fillStyle = '#f08020';
    fiCtx.fillRect(12, 12, 8, 12);
    fiCtx.fillStyle = '#f0c040';
    fiCtx.fillRect(14, 8, 4, 10);
    fiCtx.fillStyle = '#fff0a0';
    fiCtx.fillRect(15, 10, 2, 4);
    decos.campfire = fireC;

    // Signpost
    const { canvas: signC, ctx: siCtx } = this.createCanvas(S, S*2);
    siCtx.fillStyle = '#5a3a20';
    siCtx.fillRect(14, 16, 4, 32);
    siCtx.fillStyle = '#7a5a40';
    siCtx.fillRect(4, 16, 24, 10);
    siCtx.fillStyle = '#6a4a30';
    siCtx.fillRect(6, 18, 20, 6);
    decos.signpost = signC;

    // Skull (for dragon lair area)
    const { canvas: skullC, ctx: skCtx } = this.createCanvas(S, S);
    skCtx.fillStyle = '#d0d0c0';
    skCtx.fillRect(10, 14, 12, 10);
    skCtx.fillRect(12, 12, 8, 4);
    skCtx.fillStyle = '#222';
    skCtx.fillRect(12, 16, 3, 3);
    skCtx.fillRect(17, 16, 3, 3);
    skCtx.fillRect(14, 22, 4, 2);
    decos.skull = skullC;

    // Lava pool
    const { canvas: lavaC, ctx: laCtx } = this.createCanvas(S, S);
    laCtx.fillStyle = '#c03010';
    laCtx.fillRect(4, 8, 24, 16);
    laCtx.fillStyle = '#e06020';
    laCtx.fillRect(8, 10, 16, 12);
    laCtx.fillStyle = '#f0a040';
    laCtx.fillRect(12, 12, 8, 8);
    laCtx.fillStyle = '#ffe080';
    laCtx.fillRect(14, 14, 4, 4);
    decos.lava = lavaC;

    // Checkmark for completed items
    const { canvas: checkC, ctx: chkCtx } = this.createCanvas(16, 16);
    chkCtx.fillStyle = '#40e040';
    chkCtx.fillRect(2, 8, 3, 3);
    chkCtx.fillRect(4, 10, 3, 3);
    chkCtx.fillRect(6, 8, 3, 3);
    chkCtx.fillRect(8, 6, 3, 3);
    chkCtx.fillRect(10, 4, 3, 3);
    chkCtx.fillRect(12, 2, 3, 3);
    decos.checkmark = checkC;

    // Pitfall warning marker
    const { canvas: pitC, ctx: pitCtx } = this.createCanvas(S, S);
    pitCtx.fillStyle = '#5a3a20';
    pitCtx.fillRect(14, 16, 4, 14);   // post
    pitCtx.fillStyle = '#802020';
    pitCtx.fillRect(7, 7, 18, 12);    // frame
    pitCtx.fillStyle = '#b03030';
    pitCtx.fillRect(8, 8, 16, 10);    // sign face
    pitCtx.fillStyle = '#f0d060';
    pitCtx.fillRect(15, 10, 2, 5);    // exclamation
    pitCtx.fillRect(15, 16, 2, 2);
    decos.pitfall = pitC;

    // Medkit (procedural fallback) — red box with white cross
    const { canvas: medC, ctx: medCtx } = this.createCanvas(S, S);
    medCtx.fillStyle = '#c03030';
    medCtx.fillRect(8, 12, 16, 12);
    medCtx.fillStyle = '#e04040';
    medCtx.fillRect(9, 13, 14, 10);
    medCtx.fillStyle = '#fff';
    medCtx.fillRect(14, 15, 4, 6);
    medCtx.fillRect(12, 17, 8, 2);
    decos.medkit = medC;

    // Potion (procedural fallback) — green bottle
    const { canvas: potC, ctx: potCtx } = this.createCanvas(S, S);
    potCtx.fillStyle = '#206020';
    potCtx.fillRect(13, 10, 6, 14);
    potCtx.fillStyle = '#30a030';
    potCtx.fillRect(14, 12, 4, 10);
    potCtx.fillStyle = '#40e040';
    potCtx.fillRect(15, 14, 2, 6);
    potCtx.fillStyle = '#805020';
    potCtx.fillRect(14, 8, 4, 3);
    decos.potion = potC;

    return decos;
  }

  static seededRandom(seed) {
    let s = seed;
    return () => {
      s = (s * 16807 + 0) % 2147483647;
      return (s - 1) / 2147483646;
    };
  }
}

// ============================================================
// MAP GENERATOR
// ============================================================
class WorldMap {
  constructor() {
    this.cols = MAP_COLS;
    this.rows = MAP_ROWS;
    this.grid = [];
    this.decorations = [];
    this.generate();
  }

  // Fill a rectangle with terrain (only overwrites grass tiles)
  fillZone(startX, startY, w, h, terrain) {
    for (let y = startY; y < startY + h && y < this.rows; y++) {
      for (let x = startX; x < startX + w && x < this.cols; x++) {
        if (x >= 0 && y >= 0 && this.grid[y][x] === 'grass') {
          this.grid[y][x] = terrain;
        }
      }
    }
  }

  // Fill a rectangle with terrain (overwrites everything except path)
  fillZoneOver(startX, startY, w, h, terrain) {
    for (let y = startY; y < startY + h && y < this.rows; y++) {
      for (let x = startX; x < startX + w && x < this.cols; x++) {
        if (x >= 0 && y >= 0 && this.grid[y][x] !== 'path') {
          this.grid[y][x] = terrain;
        }
      }
    }
  }

  generate() {
    // Initialize with grass
    for (let y = 0; y < this.rows; y++) {
      this.grid[y] = [];
      for (let x = 0; x < this.cols; x++) {
        this.grid[y][x] = 'grass';
      }
    }

    // Compressed winding path — all shipped quests in first row, tight spacing
    const waypoints = [
      { x: 3, y: 8 },    // start
      { x: 9, y: 8 },    // item 1 — East
      { x: 15, y: 8 },   // item 2 — East
      { x: 21, y: 8 },   // item 3 — East
      { x: 27, y: 8 },   // milestone1 — East
      { x: 27, y: 15 },  // item 4 — South (turn!)
      { x: 21, y: 15 },  // item 5 — West (turn!)
      { x: 15, y: 15 },  // item 6 — West
      { x: 9, y: 15 },   // item 7 — West
      { x: 9, y: 24 },   // dragon — South (turn!)
    ];

    // Draw right-angle path segments
    for (let i = 0; i < waypoints.length - 1; i++) {
      this.drawStraightPath(waypoints[i], waypoints[i + 1]);
    }

    // ---- Terrain zones: clean axis-aligned rectangles ----
    // Every boundary is a straight horizontal or vertical line,
    // producing clean Wang tile transitions (same principle as the path).

    // Dark forest — frame the map edges with clean rectangles
    // Left darkGrass strip removed — too close to path, transitions overlapped
    this.fillZone(0, 0, this.cols, 5, 'darkGrass');               // Top band (rows 0-4)
    this.fillZone(33, 0, this.cols - 33, this.rows, 'darkGrass'); // Right strip (cols 33-39)
    this.fillZone(19, 27, this.cols - 19, this.rows - 27, 'darkGrass'); // Bottom-right block

    // (Stone courtyard removed — area is now grass with existing path running through)

    // Volcanic lair near dragon (9,24) — clean rectangle (overwrites forest)
    this.fillZoneOver(0, 19, 19, this.rows - 19, 'volcanic'); // cols 0-18, rows 19-34

    // Water ponds — clean small rectangles in grass clearings
    this.fillZone(3, 13, 3, 3, 'water');   // 3×3 pond, positioned for clean water→grass→path on all sides
    this.fillZone(22, 20, 3, 3, 'water');   // 3×3 pond, south of lower path

    // Add decorations
    this.addDecorations();
  }

  drawStraightPath(from, to) {
    // Draw a straight horizontal or vertical path (right-angle segments)
    const dx = to.x - from.x;
    const dy = to.y - from.y;

    // Determine if we go horizontal first, then vertical
    // For this layout, just draw straight since waypoints are axis-aligned
    if (dx !== 0 && dy !== 0) {
      // L-shaped: go horizontal first, then vertical
      const mid = { x: to.x, y: from.y };
      this.drawStraightPath(from, mid);
      this.drawStraightPath(mid, to);
      return;
    }

    const steps = Math.max(Math.abs(dx), Math.abs(dy));
    for (let i = 0; i <= steps; i++) {
      const px = Math.round(from.x + (dx * i / steps));
      const py = Math.round(from.y + (dy * i / steps));
      // Make path 3 tiles wide for cleaner separation
      for (let oy = -1; oy <= 1; oy++) {
        for (let ox = -1; ox <= 1; ox++) {
          const nx = px + ox, ny = py + oy;
          if (nx >= 0 && nx < this.cols && ny >= 0 && ny < this.rows) {
            this.grid[ny][nx] = 'path';
          }
        }
      }
    }
  }

  addDecorations() {
    const rng = PixelArt.seededRandom(42);

    const notTooClose = (x, y, minDist = 3) => {
      return !ROADMAP_ITEMS.some(item =>
        Math.abs(item.mapX - x) < minDist && Math.abs(item.mapY - y) < minDist
      );
    };

    const canPlace = (x, y, allowedTiles) => {
      if (!this.grid[y] || !this.grid[y][x]) return false;
      return allowedTiles.includes(this.grid[y][x]);
    };

    // Trees in dark forest (left side)
    for (let i = 0; i < 15; i++) {
      const x = Math.floor(rng() * 5);
      const y = Math.floor(rng() * this.rows);
      if (canPlace(x, y, ['darkGrass']) && notTooClose(x, y)) {
        this.decorations.push({ type: rng() > 0.3 ? 'tree0' : 'tree1', x, y });
      }
    }

    // Trees scattered across the map
    for (let i = 0; i < 30; i++) {
      const x = Math.floor(rng() * this.cols);
      const y = Math.floor(rng() * this.rows);
      if (canPlace(x, y, ['grass', 'darkGrass']) && notTooClose(x, y, 3)) {
        this.decorations.push({ type: rng() > 0.5 ? 'tree0' : 'tree1', x, y });
      }
    }

    // Extra skulls where dead trees used to be in volcanic area
    for (let i = 0; i < 6; i++) {
      const x = 2 + Math.floor(rng() * 16);
      const y = 20 + Math.floor(rng() * 12);
      if (canPlace(x, y, ['volcanic']) && notTooClose(x, y)) {
        const v = Math.floor(rng() * 16);
        this.decorations.push({ type: `skull_v${v}`, x, y });
      }
    }

    // Small rocks (16 variants from rocks-grid.png)
    const variantCount = 16;
    for (let i = 0; i < 12; i++) {
      const x = Math.floor(rng() * this.cols);
      const y = Math.floor(rng() * this.rows);
      if (canPlace(x, y, ['grass', 'darkGrass', 'stone', 'volcanic']) && notTooClose(x, y)) {
        const v = Math.floor(rng() * variantCount);
        this.decorations.push({ type: `rock_v${v}`, x, y });
      }
    }

    // Boulders (16 variants from boulders-grid.png)
    for (let i = 0; i < 6; i++) {
      const x = Math.floor(rng() * this.cols);
      const y = Math.floor(rng() * this.rows);
      if (canPlace(x, y, ['stone', 'volcanic', 'darkGrass']) && notTooClose(x, y)) {
        const v = Math.floor(rng() * variantCount);
        this.decorations.push({ type: `boulder_v${v}`, x, y });
      }
    }

    // Flowers (16 variants from flowers-grid.png)
    for (let i = 0; i < 30; i++) {
      const x = Math.floor(rng() * this.cols);
      const y = Math.floor(rng() * this.rows);
      if (canPlace(x, y, ['grass', 'darkGrass'])) {
        const v = Math.floor(rng() * variantCount);
        this.decorations.push({ type: `flower_v${v}`, x, y });
      }
    }

    // Rose bushes (16 variants from bushes-grid.png)
    for (let i = 0; i < 10; i++) {
      const x = Math.floor(rng() * this.cols);
      const y = Math.floor(rng() * this.rows);
      if (canPlace(x, y, ['grass']) && notTooClose(x, y, 2)) {
        const v = Math.floor(rng() * variantCount);
        this.decorations.push({ type: `roseBush_v${v}`, x, y });
      }
    }

    // Skulls and bones densely scattered around the dragon's lair
    // Volcanic zone: cols 0-18, rows 19-34. Dragon at (9, 24).
    for (let i = 0; i < 30; i++) {
      const x = 1 + Math.floor(rng() * 16);
      const y = 20 + Math.floor(rng() * 13);
      if (canPlace(x, y, ['volcanic']) && notTooClose(x, y, 2)) {
        const v = Math.floor(rng() * variantCount);
        this.decorations.push({ type: `skull_v${v}`, x, y });
      }
    }

    // Potions (16 variants from potions-grid.png)
    for (let i = 0; i < 6; i++) {
      const x = 3 + Math.floor(rng() * (this.cols - 6));
      const y = 3 + Math.floor(rng() * (this.rows - 6));
      if (canPlace(x, y, ['grass', 'stone']) && notTooClose(x, y, 2)) {
        const v = Math.floor(rng() * variantCount);
        this.decorations.push({ type: `potion_v${v}`, x, y });
      }
    }

    // Medkits — hidden until medkit-grid.png is added
    // for (let i = 0; i < 6; i++) { ... }

    // Sort decorations by Y for proper layering
    this.decorations.sort((a, b) => a.y - b.y);
  }

  isWalkable(x, y) {
    const col = Math.floor(x / TILE_SIZE);
    const row = Math.floor(y / TILE_SIZE);
    if (col < 0 || col >= this.cols || row < 0 || row >= this.rows) return false;
    return this.grid[row][col] === 'path';
  }
}

// ============================================================
// CHARACTER
// ============================================================
class Character {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.dir = 4; // facing south
    this.speed = 1.2;
    this.frame = 0;
    this.frameTimer = 0;
    this.moving = false;
    this.sprites = null;
    this.visitedItems = new Set();
    this.hasBow = false;
    this.jumpTimer = 0; // frames remaining in jump animation
    this.powerLevel = 1.0; // scales up on power-up
    this.targetPowerLevel = 1.0;
  }

  loadSprites(spriteData) {
    // spriteData: { walk: {dir: [Image, ...]}, idle: {dir: Image} }
    this.walkSprites = spriteData.walk;
    this.idleSprites = spriteData.idle;
    this.sprites = spriteData.walk; // Keep for compatibility checks
  }

  update(keys, worldMap) {
    let dx = 0, dy = 0;

    if (keys.up) dy -= 1;
    if (keys.down) dy += 1;
    if (keys.left) dx -= 1;
    if (keys.right) dx += 1;

    this.moving = dx !== 0 || dy !== 0;

    if (this.moving) {
      // Determine direction
      if (dx === 0 && dy < 0) this.dir = 0;
      else if (dx > 0 && dy < 0) this.dir = 1;
      else if (dx > 0 && dy === 0) this.dir = 2;
      else if (dx > 0 && dy > 0) this.dir = 3;
      else if (dx === 0 && dy > 0) this.dir = 4;
      else if (dx < 0 && dy > 0) this.dir = 5;
      else if (dx < 0 && dy === 0) this.dir = 6;
      else if (dx < 0 && dy < 0) this.dir = 7;

      // Normalize diagonal speed
      const len = Math.sqrt(dx * dx + dy * dy);
      dx = (dx / len) * this.speed;
      dy = (dy / len) * this.speed;

      // Collision box — small footprint for smooth path navigation
      const halfW = 5, halfH = 4;

      const ok = (px, py) =>
        worldMap.isWalkable(px - halfW, py - halfH) &&
        worldMap.isWalkable(px + halfW, py - halfH) &&
        worldMap.isWalkable(px - halfW, py + halfH) &&
        worldMap.isWalkable(px + halfW, py + halfH);

      const origX = this.x;
      const origY = this.y;
      const wantX = origX + dx;
      const wantY = origY + dy;

      if (ok(wantX, wantY)) {
        // Best case: full diagonal / straight move
        this.x = wantX;
        this.y = wantY;
      } else if (dx !== 0 && ok(wantX, origY)) {
        // Slide along X (wall blocks Y)
        this.x = wantX;
      } else if (dy !== 0 && ok(origX, wantY)) {
        // Slide along Y (wall blocks X)
        this.y = wantY;
      } else if (dx !== 0) {
        // X blocked — try nudging perpendicular (Y) to slide around corner
        for (let n = 1; n <= 16; n++) {
          if (ok(wantX, origY - n)) { this.x = wantX; this.y = origY - n; break; }
          if (ok(wantX, origY + n)) { this.x = wantX; this.y = origY + n; break; }
        }
      } else if (dy !== 0) {
        // Y blocked — try nudging perpendicular (X) to slide around corner
        for (let n = 1; n <= 16; n++) {
          if (ok(origX - n, wantY)) { this.y = wantY; this.x = origX - n; break; }
          if (ok(origX + n, wantY)) { this.y = wantY; this.x = origX + n; break; }
        }
      }

      // Safety: never allow an invalid position
      if (!ok(this.x, this.y)) {
        this.x = origX;
        this.y = origY;
      }

      // Clamp to map
      this.x = Math.max(12, Math.min(this.x, MAP_COLS * TILE_SIZE - 12));
      this.y = Math.max(12, Math.min(this.y, MAP_ROWS * TILE_SIZE - 12));

      // Animate — slower cycle for Pokemon-like cadence
      this.frameTimer++;
      if (this.frameTimer > 12) {
        this.frameTimer = 0;
        this.frame = (this.frame + 1) % 6;
      }
    } else {
      this.frame = 0;
      this.frameTimer = 0;
    }

    // Tick jump animation
    if (this.jumpTimer > 0) this.jumpTimer--;
  }

  draw(ctx, cameraX, cameraY) {
    if (!this.sprites) return;
    // Smoothly animate power level
    if (this.powerLevel < this.targetPowerLevel) {
      this.powerLevel = Math.min(this.targetPowerLevel, this.powerLevel + 0.01);
    }
    const dirName = DIR_NAMES[this.dir];
    let sprite;
    if (this.moving && this.walkSprites && this.walkSprites[dirName]) {
      sprite = this.walkSprites[dirName][this.frame];
    } else if (this.idleSprites && this.idleSprites[dirName]) {
      sprite = this.idleSprites[dirName];
    } else {
      sprite = this.walkSprites[dirName][0];
    }
    const jumpOffset = this.jumpTimer > 0 ? Math.sin((this.jumpTimer / 12) * Math.PI) * 14 : 0;
    // Subtle walk bob — 2px bounce per step, Pokemon-style
    const walkBob = this.moving ? Math.abs(Math.sin(this.frameTimer / 12 * Math.PI)) * 2 : 0;
    const scale = this.powerLevel;
    const sw = 48 * scale;
    const sh = 48 * scale;
    const drawX = this.x - cameraX - sw / 2;
    const drawY = this.y - cameraY - (sh * 40 / 48) - jumpOffset - walkBob;
    ctx.drawImage(sprite, drawX, drawY, sw, sh);

    // Draw held bow (same sprite as the pickup on the map)
    if (this.hasBow && this.bowSprite) {
      const d = this.dir;
      let ox, oy, flip;
      if (d === 2 || d === 1 || d === 3) {
        ox = 20 * scale; oy = -4; flip = false;
      } else if (d === 6 || d === 5 || d === 7) {
        ox = -4 * scale; oy = -4; flip = true;
      } else if (d === 0) {
        ox = 18 * scale; oy = -2; flip = false;
      } else {
        ox = -2 * scale; oy = -2; flip = true;
      }
      const bob = this.moving ? Math.sin(this.frameTimer * 0.6) * 1.5 : 0;
      const bx = drawX + ox;
      const by = drawY + oy + bob;
      const bowSize = 24; // Render held bow at 24px

      ctx.save();
      ctx.imageSmoothingEnabled = false;
      if (flip) {
        ctx.translate(bx + bowSize / 2, by + bowSize / 2);
        ctx.scale(-1, 1);
        ctx.translate(-(bx + bowSize / 2), -(by + bowSize / 2));
      }
      ctx.drawImage(this.bowSprite, bx, by, bowSize, bowSize);
      ctx.restore();
    }
  }

  getNearbyItem(range = 48) {
    for (const item of ROADMAP_ITEMS) {
      const ix = item.mapX * TILE_SIZE + TILE_SIZE / 2;
      const iy = item.mapY * TILE_SIZE + TILE_SIZE / 2;
      const dist = Math.sqrt((this.x - ix) ** 2 + (this.y - iy) ** 2);
      if (dist < range) return item;
    }
    return null;
  }
}

// ============================================================
// PARTICLE SYSTEM
// ============================================================
class ParticleSystem {
  constructor() {
    this.particles = [];
  }

  emit(x, y, count, options = {}) {
    for (let i = 0; i < count; i++) {
      this.particles.push({
        x, y,
        vx: (Math.random() - 0.5) * (options.speed || 3),
        vy: (Math.random() - 0.5) * (options.speed || 3) - (options.upward ? 2 : 0),
        life: options.life || 30 + Math.random() * 30,
        maxLife: options.life || 30 + Math.random() * 30,
        color: options.colors ? options.colors[Math.floor(Math.random() * options.colors.length)] : '#f0c040',
        size: options.size || 2 + Math.random() * 3,
        gravity: options.gravity || 0
      });
    }
  }

  update() {
    this.particles = this.particles.filter(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += p.gravity;
      p.life--;
      return p.life > 0;
    });
  }

  draw(ctx, cameraX, cameraY) {
    for (const p of this.particles) {
      const alpha = p.life / p.maxLife;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = p.color;
      ctx.fillRect(
        Math.round(p.x - cameraX),
        Math.round(p.y - cameraY),
        Math.round(p.size),
        Math.round(p.size)
      );
    }
    ctx.globalAlpha = 1;
  }
}

// ============================================================
// GAME ENGINE
// ============================================================
class Game {
  constructor() {
    this.canvas = document.getElementById('game-canvas');
    this.ctx = this.canvas.getContext('2d');
    this.minimapCanvas = document.getElementById('minimap');
    this.minimapCtx = this.minimapCanvas.getContext('2d');

    this.width = 0;
    this.height = 0;

    // Camera
    this.cameraX = 0;
    this.cameraY = 0;
    this.targetCameraX = 0;
    this.targetCameraY = 0;

    // Zoom (mutable)
    this.zoom = DEFAULT_ZOOM;

    // Input
    this.keys = { up: false, down: false, left: false, right: false };
    this.moveTarget = null;
    this.pathQueue = [];
    this.lastAutoMoveDistance = null;
    this.autoMoveStuckFrames = 0;
    this.tapIndicator = null;

    // Game phase state machine
    // 'loading' -> 'opening_dragon' -> 'opening_pan' -> 'opening_bard' -> 'playing' -> 'dragon_fight' -> 'victory'
    this.gamePhase = 'loading';

    // Game state
    this.loaded = false;
    this.tiles = null;
    this.decos = null;
    this.worldMap = null;
    this.character = null;
    this.particles = new ParticleSystem();

    // Audio — lazy-init Web Audio on first user interaction
    this.audioCtx = null;
    this.audioUnlocked = false;
    this.currentMusic = null; // { type, intervalId, nodes[] }
    this.musicGain = null;

    this.activePanel = null;
    this.milestoneShown = new Set();
    this.discoveredPitfalls = new Set();
    this.shownMilestoneBanner = null;
    this.milestoneBannerTimer = 0;
    this.milestoneDialogActive = false;
    this.milestoneDialogCallback = null;
    this.dragonSlain = false;
    this.dragonFightActive = false;
    this.dragonMaxHP = 40;
    this.dragonHP = this.dragonMaxHP;
    this.dragonHitTimer = 0;
    this.hitFlashTimer = 0;
    this.victoryFlashTimer = 0;
    this.arrowsFired = [];
    this.interactCooldown = 0;
    this.coins = [];
    this.coinsCollected = 0;
    this.totalCoins = 0;
    this.itemGlowPhase = 0;
    this.time = 0;

    // Label visibility tracking
    this.labelFadeIn = {};

    // Opening scene state
    this.openingTimer = 0;
    this.openingTextIndex = 0;
    this.openingText = "I have stolen all the attention of doctors!! No one can slay me!!";

    // Doctor NPCs (celebrating after milestone 1)
    this.doctors = [];
    this.doctorSprites = [];
    this.doctorsSpawned = false;

    // Victory/CTA state
    this.victoryTimer = 0;

    // Roadmap overlay visible
    this.roadmapOverlayVisible = false;

    this.init();
  }

  async init() {
    this.resize();
    window.addEventListener('resize', () => this.resize());
    this.setupInput();

    // Simulate loading
    const loadBar = document.getElementById('load-bar');
    const loadText = document.getElementById('load-text');

    loadText.textContent = 'Generating terrain...';
    loadBar.style.width = '20%';
    await this.sleep(200);

    this.tiles = PixelArt.generateTiles();
    loadText.textContent = 'Loading tilesets...';
    loadBar.style.width = '28%';
    await this.sleep(100);

    // Load PixelLab Wang tilesets in parallel
    loadText.textContent = 'Placing landmarks...';
    loadBar.style.width = '35%';
    const [grassPathTiles, grassWaterTiles, grassDarkTiles, grassStoneTiles, grassVolcanicTiles, pathVolcanicTiles] = await Promise.all([
      PixelArt.loadWangTileset('assets/tilesets/grass_path.png', 'assets/tilesets/grass_path_meta.json'),
      PixelArt.loadWangTileset('assets/tilesets/grass_water.png', 'assets/tilesets/grass_water_meta.json'),
      PixelArt.loadWangTileset('assets/tilesets/grass_darkgrass.png', 'assets/tilesets/grass_darkgrass_meta.json'),
      PixelArt.loadWangTileset('assets/tilesets/grass_stone.png', 'assets/tilesets/grass_stone_meta.json'),
      PixelArt.loadWangTileset('assets/tilesets/grass_volcanic.png', 'assets/tilesets/grass_volcanic_meta.json'),
      PixelArt.loadWangTileset('assets/tilesets/path_volcanic.png', 'assets/tilesets/path_volcanic_meta.json')
    ]);
    this.wangGrassPath = grassPathTiles;        // lower=grass, upper=path
    this.wangGrassWater = grassWaterTiles;      // lower=grass, upper=water
    this.wangGrassDark = grassDarkTiles;        // lower=grass, upper=darkGrass
    this.wangGrassStone = grassStoneTiles;      // lower=grass, upper=stone
    this.wangGrassVolcanic = grassVolcanicTiles; // lower=grass, upper=volcanic
    this.wangPathVolcanic = pathVolcanicTiles;   // lower=path, upper=volcanic

    // Darken all tileset tiles to reduce bright grass
    const GRASS_DARKEN = 0.2;
    [this.wangGrassPath, this.wangGrassWater, this.wangGrassDark,
     this.wangGrassStone, this.wangGrassVolcanic, this.wangPathVolcanic].forEach(tileset => {
      tileset.forEach(tile => { if (tile) PixelArt.darkenCanvas(tile, GRASS_DARKEN); });
    });

    loadText.textContent = 'Growing forests...';
    loadBar.style.width = '45%';
    await this.sleep(150);

    this.decos = PixelArt.generateDecorations();
    loadText.textContent = 'Loading decorations...';
    loadBar.style.width = '50%';

    // Replace procedural assets with PixelLab-generated ones
    const loadAssetImg = (src) => new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        const c = document.createElement('canvas');
        c.width = img.width; c.height = img.height;
        c.getContext('2d').drawImage(img, 0, 0);
        resolve(c);
      };
      img.onerror = () => resolve(null); // graceful fallback
      img.src = src;
    });

    // Load isometric tile and auto-crop the diamond base
    // Scans from bottom to find the base edge, then keeps only the object above it
    const loadAssetImgCropped = (src, cropRatio = 0.35) => new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        const w = img.width, h = img.height;
        // Draw full image to temp canvas to read pixel data
        const tmp = document.createElement('canvas');
        tmp.width = w; tmp.height = h;
        const tCtx = tmp.getContext('2d');
        tCtx.drawImage(img, 0, 0);
        const data = tCtx.getImageData(0, 0, w, h).data;

        // Find the topmost row that has opaque pixels (the actual object)
        let topRow = h;
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            if (data[(y * w + x) * 4 + 3] > 10) { topRow = y; break; }
          }
          if (topRow < h) break;
        }

        // Crop bottom portion (the isometric base) by removing cropRatio from bottom
        const cropH = Math.floor(h * cropRatio);
        const keepH = h - cropH;
        const c = document.createElement('canvas');
        c.width = w; c.height = keepH;
        c.getContext('2d').drawImage(img, 0, 0, w, keepH, 0, 0, w, keepH);
        resolve(c);
      };
      img.onerror = () => resolve(null);
      img.src = src;
    });

    const treeCanvas = await loadAssetImg('assets/trees/pine_south.png');
    if (treeCanvas) { this.decos.tree0 = treeCanvas; this.decos.tree1 = treeCanvas; }

    // Generic grid loader: splits a grid PNG into individual variant sprites
    const DECO_SIZE = TILE_SIZE / 2; // 16px — half-tile for decorations
    const loadGrid = async (src, prefix, gridCols = 4, gridRows = 4, size = DECO_SIZE) => {
      const grid = await loadAssetImg(src);
      if (!grid) return 0;
      const cellW = grid.width / gridCols;
      const cellH = grid.height / gridRows;
      const count = gridCols * gridRows;
      for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
          const idx = row * gridCols + col;
          const c = document.createElement('canvas');
          c.width = size; c.height = size;
          const ctx = c.getContext('2d');
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(grid, col * cellW, row * cellH, cellW, cellH, 0, 0, size, size);
          this.decos[`${prefix}_v${idx}`] = c;
        }
      }
      return count;
    };

    // Load all decoration grids (4x4 = 16 variants each, rendered at 16px)
    await loadGrid('assets/decorations/flowers-grid.png', 'flower');
    await loadGrid('assets/decorations/rocks-grid.png', 'rock');
    await loadGrid('assets/decorations/boulders-grid.png', 'boulder');
    await loadGrid('assets/decorations/skulls-grid.png', 'skull');
    await loadGrid('assets/decorations/bushes-grid.png', 'roseBush');
    await loadGrid('assets/decorations/potions-grid.png', 'potion');

    // Load bow grid and use first variant as the bow pickup sprite
    const bowCount = await loadGrid('assets/decorations/bows-grid.png', 'bow_opt', 4, 4, TILE_SIZE);
    if (bowCount > 0) this.decos.bow = this.decos['bow_opt_v0'];

    // Load other decoration sprites (single PNGs)
    const decoAssets = {
      campfire: 'assets/decorations/campfire.png',
      // (deadTree removed — replaced with skull decorations)
      lava: 'assets/decorations/lava.png',
      flag: 'assets/decorations/flag.png',
      bridge: 'assets/decorations/bridge.png',
    };
    for (const [key, src] of Object.entries(decoAssets)) {
      const c = await loadAssetImg(src);
      if (c) this.decos[key] = c;
    }

    // Load PixelLab dragon sprite (replaces procedural dragon)
    const dragonCanvas = await loadAssetImg('assets/dragon/south.png');
    if (dragonCanvas) this.decos.dragon = dragonCanvas;

    // Load coin rotation frames from coins.png spritesheet (3x3 grid, 32x32 per cell)
    // Contains pre-drawn rotation frames for a spinning gold coin
    this.coinFrames = [];
    const coinSheet = await loadAssetImg('assets/decorations/coins.png');
    if (coinSheet) {
      const gridCols = 3, gridRows = 3;
      const cellW = coinSheet.width / gridCols;
      const cellH = coinSheet.height / gridRows;
      const coinSize = 16; // rendered size in game
      const totalCells = gridCols * gridRows;
      for (let i = 0; i < totalCells; i++) {
        const col = i % gridCols;
        const row = Math.floor(i / gridCols);
        const fc = document.createElement('canvas');
        fc.width = coinSize; fc.height = coinSize;
        const fctx = fc.getContext('2d');
        fctx.imageSmoothingEnabled = false;
        fctx.drawImage(coinSheet, col * cellW, row * cellH, cellW, cellH, 0, 0, coinSize, coinSize);
        this.coinFrames.push(fc);
      }
    }
    if (this.coinFrames.length === 0) {
      // Fallback: procedural gold coin if spritesheet not available
      const frameCount = 8;
      const coinSize = 14;
      for (let i = 0; i < frameCount; i++) {
        const angle = (i / frameCount) * Math.PI * 2;
        const scaleX = Math.abs(Math.cos(angle));
        const coinW = Math.max(2, Math.round(coinSize * scaleX));
        const fc = document.createElement('canvas');
        fc.width = coinW + 2; fc.height = coinSize + 2;
        const fctx = fc.getContext('2d');
        const cx = (coinW + 2) / 2;
        const cy = (coinSize + 2) / 2;
        const rx = coinW / 2;
        const ry = coinSize / 2;
        fctx.fillStyle = '#8a6010';
        fctx.beginPath(); fctx.ellipse(cx, cy, rx + 1, ry + 1, 0, 0, Math.PI * 2); fctx.fill();
        fctx.fillStyle = '#d4a020';
        fctx.beginPath(); fctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2); fctx.fill();
        if (coinW > 4) {
          fctx.fillStyle = '#f0d060';
          fctx.beginPath(); fctx.ellipse(cx, cy - ry * 0.2, rx * 0.7, ry * 0.5, 0, 0, Math.PI * 2); fctx.fill();
        }
        this.coinFrames.push(fc);
      }
    }
    this.coinSprite = this.coinFrames.length > 0 ? this.coinFrames[0] : null;

    // Load castle grid and slice into individual sprites for shipped stops
    this.castleSprites = {}; // keyed by item id
    const castleGrid = await new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => resolve(null);
      img.src = 'assets/items/castle/castle-grid.png';
    });
    if (castleGrid) {
      // 4x4 grid — each cell is gridW/4 × gridH/4
      const cols = 4, rows = 4;
      const cellW = castleGrid.width / cols;
      const cellH = castleGrid.height / rows;
      // Pick 3 distinct castles for the 3 shipped items (row, col):
      // Item 1: row 0, col 0 (blue flag castle)
      // Item 2: row 0, col 2 (red turret castle)
      // Item 3: row 1, col 2 (large brown castle)
      const picks = [ [0, 0], [0, 2], [1, 2] ];
      const shippedIds = [1, 2, 3];
      for (let i = 0; i < shippedIds.length; i++) {
        const [r, c] = picks[i];
        const sliceCanvas = document.createElement('canvas');
        sliceCanvas.width = cellW;
        sliceCanvas.height = cellH;
        const sCtx = sliceCanvas.getContext('2d');
        sCtx.drawImage(castleGrid, c * cellW, r * cellH, cellW, cellH, 0, 0, cellW, cellH);
        this.castleSprites[shippedIds[i]] = sliceCanvas;
      }
    }
    // Fallback: single castle sprite
    this.castleSprite = this.castleSprites[1] || null;

    // Load tent grid and slice into individual sprites for upcoming stops
    this.tentSprites = {}; // keyed by item id
    const tentGrid = await new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => resolve(null);
      img.src = 'assets/decorations/tents-grid.png';
    });
    if (tentGrid) {
      const cols = 4, rows = 4;
      const cellW = tentGrid.width / cols;
      const cellH = tentGrid.height / rows;
      // Pick 4 distinct tents for the 4 upcoming items (row, col):
      // Item 4: row 0, col 0 (red/blue striped tent)
      // Item 5: row 0, col 2 (blue peaked tent)
      // Item 6: row 1, col 1 (teal striped tent)
      // Item 7: row 2, col 0 (blue/gold tent)
      const picks = [ [0, 0], [0, 2], [1, 1], [2, 0] ];
      const upcomingIds = [4, 5, 6, 7];
      for (let i = 0; i < upcomingIds.length; i++) {
        const [r, c] = picks[i];
        const sliceCanvas = document.createElement('canvas');
        sliceCanvas.width = cellW;
        sliceCanvas.height = cellH;
        const sCtx = sliceCanvas.getContext('2d');
        sCtx.drawImage(tentGrid, c * cellW, r * cellH, cellW, cellH, 0, 0, cellW, cellH);
        this.tentSprites[upcomingIds[i]] = sliceCanvas;
      }
    }
    // Fallback: single tent sprite
    this.tentSprite = this.tentSprites[4] || null;

    loadText.textContent = 'Summoning Bard the Bowman...';
    loadBar.style.width = '60%';

    const charSprites = await PixelArt.loadCharacterSprites();
    loadText.textContent = 'Awakening the dragon...';
    loadBar.style.width = '75%';
    await this.sleep(100);

    loadText.textContent = 'Preparing the quest...';
    loadBar.style.width = '80%';
    await this.sleep(200);

    this.worldMap = new WorldMap();
    this.character = new Character(3 * TILE_SIZE + TILE_SIZE / 2, 8 * TILE_SIZE + TILE_SIZE / 2);
    this.character.loadSprites(charSprites);

    // Load doctor sprites (graceful fallback if not found)
    await this.loadDoctorSprites();

    // Generate coins along the path
    this.generateCoins();

    loadText.textContent = 'Quest begins!';
    loadBar.style.width = '100%';
    await this.sleep(400);

    document.getElementById('loading').style.display = 'none';

    // Show mobile banner if on mobile
    if (/Mobi|Android/i.test(navigator.userAgent)) {
      const mobileBanner = document.getElementById('mobile-banner');
      mobileBanner.style.display = 'block';
      document.getElementById('mobile-close').addEventListener('click', () => {
        mobileBanner.style.display = 'none';
      });
    }

    // Pre-render minimap and one frame
    this.loaded = true;
    this.renderMinimap();

    // Start opening scene — camera on Bard, show intro scroll
    const viewW = this.width / this.zoom;
    const viewH = this.height / this.zoom;
    this.cameraX = this.character.x - viewW / 2;
    this.cameraY = this.character.y - viewH / 2;
    this.targetCameraX = this.cameraX;
    this.targetCameraY = this.cameraY;

    this.gamePhase = 'opening_bard';
    this.openingTimer = 0;
    document.getElementById('intro-backdrop').classList.add('visible');
    document.getElementById('intro-scroll').classList.add('visible');

    // Start game loop
    this.loop();
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  resize() {
    this.width = window.innerWidth;
    this.height = window.innerHeight;
    this.canvas.width = this.width;
    this.canvas.height = this.height;
    this.ctx.imageSmoothingEnabled = false;
  }

  // Compute Wang tile index for a cell based on which neighbor terrain matches 'upperTerrain'
  // Each corner vertex checks the 4 tiles sharing it; if any is the upper terrain, that corner = 1
  getWangIndex(col, row, upperTerrain) {
    const grid = this.worldMap.grid;
    const rows = this.worldMap.rows;
    const cols = this.worldMap.cols;

    const isUpper = (c, r) => {
      if (c < 0 || r < 0 || c >= cols || r >= rows) return false;
      return grid[r][c] === upperTerrain;
    };

    // NW vertex at (col, row): shared by tiles (col-1,row-1), (col,row-1), (col-1,row), (col,row)
    const nw = (isUpper(col-1,row-1) || isUpper(col,row-1) || isUpper(col-1,row) || isUpper(col,row)) ? 1 : 0;
    // NE vertex at (col+1, row): shared by tiles (col,row-1), (col+1,row-1), (col,row), (col+1,row)
    const ne = (isUpper(col,row-1) || isUpper(col+1,row-1) || isUpper(col,row) || isUpper(col+1,row)) ? 1 : 0;
    // SW vertex at (col, row+1): shared by tiles (col-1,row), (col,row), (col-1,row+1), (col,row+1)
    const sw = (isUpper(col-1,row) || isUpper(col,row) || isUpper(col-1,row+1) || isUpper(col,row+1)) ? 1 : 0;
    // SE vertex at (col+1, row+1): shared by tiles (col,row), (col+1,row), (col,row+1), (col+1,row+1)
    const se = (isUpper(col,row) || isUpper(col+1,row) || isUpper(col,row+1) || isUpper(col+1,row+1)) ? 1 : 0;

    return nw * 8 + ne * 4 + sw * 2 + se;
  }

  cancelAutoMove(clearKeys = false) {
    this.moveTarget = null;
    this.pathQueue = [];
    this.lastAutoMoveDistance = null;
    this.autoMoveStuckFrames = 0;
    if (clearKeys) {
      this.keys.up = false;
      this.keys.down = false;
      this.keys.left = false;
      this.keys.right = false;
    }
  }

  isPathTile(col, row) {
    return (
      row >= 0 &&
      row < this.worldMap.rows &&
      col >= 0 &&
      col < this.worldMap.cols &&
      this.worldMap.grid[row][col] === 'path'
    );
  }

  findNearestPathTile(worldX, worldY, maxRadius = 2) {
    const baseCol = Math.floor(worldX / TILE_SIZE);
    const baseRow = Math.floor(worldY / TILE_SIZE);

    if (this.isPathTile(baseCol, baseRow)) {
      return { col: baseCol, row: baseRow };
    }

    let best = null;
    let bestDistSq = Infinity;
    for (let radius = 1; radius <= maxRadius; radius++) {
      for (let row = baseRow - radius; row <= baseRow + radius; row++) {
        for (let col = baseCol - radius; col <= baseCol + radius; col++) {
          if (!this.isPathTile(col, row)) continue;
          const cx = col * TILE_SIZE + TILE_SIZE / 2;
          const cy = row * TILE_SIZE + TILE_SIZE / 2;
          const dx = cx - worldX;
          const dy = cy - worldY;
          const distSq = dx * dx + dy * dy;
          if (distSq < bestDistSq) {
            bestDistSq = distSq;
            best = { col, row };
          }
        }
      }
      if (best) return best;
    }
    return null;
  }

  planPathTo(worldX, worldY) {
    const startTile = this.findNearestPathTile(this.character.x, this.character.y, 1);
    const targetTile = this.findNearestPathTile(worldX, worldY, 2);
    if (!startTile || !targetTile) return null;

    const keyOf = (col, row) => `${col},${row}`;
    const parseKey = (key) => {
      const [colStr, rowStr] = key.split(',');
      return { col: Number(colStr), row: Number(rowStr) };
    };

    const startKey = keyOf(startTile.col, startTile.row);
    const targetKey = keyOf(targetTile.col, targetTile.row);
    const queue = [startTile];
    const visited = new Set([startKey]);
    const parent = new Map();
    const dirs = [
      [1, 0], [-1, 0],
      [0, 1], [0, -1]
    ];

    while (queue.length > 0) {
      const current = queue.shift();
      const currentKey = keyOf(current.col, current.row);
      if (currentKey === targetKey) break;

      for (const [dx, dy] of dirs) {
        const nc = current.col + dx;
        const nr = current.row + dy;
        if (!this.isPathTile(nc, nr)) continue;
        const nextKey = keyOf(nc, nr);
        if (visited.has(nextKey)) continue;
        visited.add(nextKey);
        parent.set(nextKey, currentKey);
        queue.push({ col: nc, row: nr });
      }
    }

    if (!visited.has(targetKey)) return null;

    const tilePath = [];
    let walkKey = targetKey;
    while (walkKey) {
      tilePath.push(parseKey(walkKey));
      if (walkKey === startKey) break;
      walkKey = parent.get(walkKey);
    }
    tilePath.reverse();

    const waypoints = tilePath.slice(1).map((tile) => ({
      x: tile.col * TILE_SIZE + TILE_SIZE / 2,
      y: tile.row * TILE_SIZE + TILE_SIZE / 2
    }));

    this.pathQueue = waypoints;
    if (this.pathQueue.length > 0) {
      this.moveTarget = this.pathQueue.shift();
    } else {
      this.moveTarget = {
        x: targetTile.col * TILE_SIZE + TILE_SIZE / 2,
        y: targetTile.row * TILE_SIZE + TILE_SIZE / 2
      };
    }
    this.lastAutoMoveDistance = null;
    this.autoMoveStuckFrames = 0;

    return {
      x: targetTile.col * TILE_SIZE + TILE_SIZE / 2,
      y: targetTile.row * TILE_SIZE + TILE_SIZE / 2
    };
  }

  setupInput() {
    window.addEventListener('keydown', (e) => {
      if (this.gamePhase === 'dragon_fight') return; // No movement during boss fight
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') { this.cancelAutoMove(); this.keys.up = true; e.preventDefault(); }
      if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') { this.cancelAutoMove(); this.keys.down = true; e.preventDefault(); }
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') { this.cancelAutoMove(); this.keys.left = true; e.preventDefault(); }
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') { this.cancelAutoMove(); this.keys.right = true; e.preventDefault(); }
      if (e.key === 'Escape') {
        e.preventDefault();
        this.closePanel();
        if (this.roadmapOverlayVisible) this.hideRoadmapOverlay();
      }
    });

    window.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') this.keys.up = false;
      if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') this.keys.down = false;
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') this.keys.left = false;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') this.keys.right = false;
    });

    // Tap / click-to-move on canvas
    const canvas = this.canvas;
    const handleTap = (pageX, pageY) => {
      if (this.milestoneDialogActive) return;
      if (this.gamePhase !== 'playing') return;

      const rect = canvas.getBoundingClientRect();
      // Convert page coords → canvas logical coords → world coords
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const canvasX = (pageX - rect.left) * scaleX;
      const canvasY = (pageY - rect.top) * scaleY;

      // Canvas renders with camera offset — convert to world position
      const worldX = canvasX + this.cameraX;
      const worldY = canvasY + this.cameraY;

      // Path-only movement with path routing: snap taps near the road and follow turns.
      const destination = this.planPathTo(worldX, worldY);
      if (!destination) {
        this.cancelAutoMove(true);
        this.tapIndicator = { x: worldX, y: worldY, alpha: 1.0, blocked: true };
        this.ensureAudio();
        return;
      }

      this.tapIndicator = { x: destination.x, y: destination.y, alpha: 1.0, blocked: false };
      this.ensureAudio(); // unlock audio on first touch gesture
    };

    // Touch events (primary)
    canvas.addEventListener('touchstart', (e) => {
      // Ignore multi-touch (pinch zoom etc.)
      if (e.touches.length !== 1) return;
      const t = e.touches[0];
      handleTap(t.clientX, t.clientY);
      e.preventDefault();
    }, { passive: false });

    // Mouse click fallback (also useful for desktop click-to-move)
    canvas.addEventListener('click', (e) => {
      handleTap(e.clientX, e.clientY);
    });

    // GO button — start the game (also unlocks audio on user gesture)
    document.getElementById('go-btn').addEventListener('click', () => {
      document.getElementById('intro-backdrop').classList.remove('visible');
      document.getElementById('intro-scroll').classList.remove('visible');
      this.gamePhase = 'playing';
      this.ensureAudio();
      this.startExploreMusic();
    });

    // Slay button — fire arrow at dragon
    document.getElementById('slay-btn').addEventListener('click', (e) => {
      e.stopPropagation(); // prevent click reaching canvas
      if (this.dragonFightActive && !this.dragonSlain) {
        this.fireDragonArrow();
      }
    });

    // Mute toggle
    this.muted = false;
    document.getElementById('mute-btn').addEventListener('click', () => {
      this.muted = !this.muted;
      const btn = document.getElementById('mute-btn');
      if (this.muted) {
        btn.textContent = '♪';
        btn.classList.add('muted');
        btn.title = 'Unmute audio';
        // Mute master audio
        if (this.audioCtx) {
          this.audioCtx.suspend();
        }
        this.stopMusic();
      } else {
        btn.textContent = '♪';
        btn.classList.remove('muted');
        btn.title = 'Mute audio';
        // Resume audio
        if (this.audioCtx) {
          this.audioCtx.resume();
        }
        // Restart appropriate music
        if (this.gamePhase === 'dragon_fight') {
          this.startBossMusic();
        } else if (this.gamePhase === 'playing') {
          this.startExploreMusic();
        }
      }
    });

    // Scroll wheel zoom (kept without buttons)
    window.addEventListener('wheel', (e) => {
      if (this.gamePhase !== 'playing') return;
      if (e.deltaY < 0) this.zoom = Math.min(3.5, this.zoom + 0.15);
      else this.zoom = Math.max(1.5, this.zoom - 0.15);
    }, { passive: true });

    // Roadmap button
    document.getElementById('roadmap-btn').addEventListener('click', () => {
      this.showRoadmapOverlay();
    });
    document.getElementById('roadmap-close').addEventListener('click', (e) => {
      e.stopPropagation();
      this.hideRoadmapOverlay();
    });
    // Also close roadmap when clicking the dark overlay background (not the scroll content)
    document.getElementById('roadmap-overlay').addEventListener('click', (e) => {
      if (e.target === document.getElementById('roadmap-overlay')) {
        this.hideRoadmapOverlay();
      }
    });

    // Victory screen buttons
    document.getElementById('review-roadmap-btn').addEventListener('click', () => {
      document.getElementById('victory-screen').classList.remove('visible');
      this.showRoadmapOverlay();
    });

    document.getElementById('play-again-btn').addEventListener('click', () => {
      window.location.reload();
    });

  }

  closePanel() {
    this.activePanel = null;
    const panel = document.getElementById('info-panel');
    panel.classList.remove('visible');
  }

  getNearbyPitfall(range = 56) {
    for (const pitfall of PITFALLS) {
      const px = pitfall.mapX * TILE_SIZE + TILE_SIZE / 2;
      const py = pitfall.mapY * TILE_SIZE + TILE_SIZE / 2;
      const dist = Math.sqrt((this.character.x - px) ** 2 + (this.character.y - py) ** 2);
      if (dist < range) return pitfall;
    }
    return null;
  }

  interactWithPitfall(pitfall) {
    this.activePanel = pitfall;
    this.discoveredPitfalls.add(pitfall.id);

    const panel = document.getElementById('info-panel');
    const status = document.getElementById('panel-status');
    const title = document.getElementById('panel-title');
    const desc = document.getElementById('panel-desc');
    const explore = document.getElementById('panel-explore');

    status.textContent = 'PITFALL TO AVOID';
    status.className = 'panel-status pitfall';
    title.innerHTML = `<span class="panel-number">${pitfall.id}</span>${pitfall.title}`;
    desc.textContent = `Risk: ${pitfall.risk} Mitigation: ${pitfall.mitigation}`;
    explore.classList.add('hidden');
    panel.classList.add('visible');

    this.playUpcomingSound();
  }

  interactWithItem(item) {
    if (item.status === 'milestone') {
      this.activePanel = item;

      // Bow pickup + power-up
      if (item.id === 'milestone1' && !this.character.hasBow) {
        this.character.hasBow = true;
        this.character.bowSprite = this.decos.bow;
        this.character.targetPowerLevel = 1.3;
        this.playLevelUpSound();
        // Power-up particle burst
        this.particles.emit(this.character.x, this.character.y - 20, 25, {
          colors: ['#f0c040', '#ffe070', '#fff8d0', '#40e040'],
          speed: 6,
          upward: true,
          life: 50,
          gravity: -0.05
        });
        if (!this.doctorsSpawned) {
          this.spawnDoctors(item.mapX, item.mapY);
        }
        if (!this.milestoneShown.has(item.id)) {
          this.milestoneShown.add(item.id);
          this.showMilestoneDialog(
            'LEVEL UP!\nBOW ACQUIRED',
            'Bard has collected the bow.\nYou are now empowered to slay the Dragon.\nContinue south to find the beast!'
          );
        }
        return;
      }

      // Dragon encounter
      if (item.id === 'milestone2' && !this.dragonSlain && !this.dragonFightActive) {
        if (!this.milestoneShown.has(item.id)) {
          this.milestoneShown.add(item.id);
          this.showMilestoneDialog(
            'BOSS BATTLE\nTHE DRAGON AWAITS',
            'You have reached the Dragon\'s lair.\nPrepare for battle!',
            () => { this.startDragonFight(); }
          );
        } else {
          this.startDragonFight();
        }
        return;
      }

      if (!this.milestoneShown.has(item.id)) {
        this.milestoneShown.add(item.id);
        this.showMilestoneBanner(item.title);
      }
      return;
    }

    this.character.visitedItems.add(item.id);
    this.activePanel = item;

    const panel = document.getElementById('info-panel');
    const status = document.getElementById('panel-status');
    const title = document.getElementById('panel-title');
    const desc = document.getElementById('panel-desc');
    const explore = document.getElementById('panel-explore');

    if (item.status === 'shipped') {
      status.textContent = 'SHIPPED';
      status.className = 'panel-status';
      this.playShippedSound();
    } else {
      status.textContent = 'ON THE ROADMAP';
      status.className = 'panel-status upcoming';
      this.playUpcomingSound();
    }

    title.innerHTML = `<span class="panel-number">${item.id}</span>${item.title}`;
    desc.textContent = item.description;

    // Show/hide explore docs button
    if (item.docsUrl) {
      explore.href = item.docsUrl;
      explore.classList.remove('hidden');
    } else {
      explore.classList.add('hidden');
    }

    panel.classList.add('visible');
  }

  showMilestoneBanner(text) {
    this.shownMilestoneBanner = text;
    this.milestoneBannerTimer = 180;
    const banner = document.getElementById('milestone-banner');
    const bannerText = document.getElementById('banner-text');
    bannerText.textContent = text;
    banner.classList.add('visible');
  }

  showMilestoneDialog(title, desc, callback) {
    this.milestoneDialogActive = true;
    this.milestoneDialogCallback = callback || null;
    document.getElementById('md-title').textContent = title;
    document.getElementById('md-desc').textContent = desc;
    document.getElementById('milestone-dialog').classList.add('visible');

    // Dismiss on any key or tap (once) — clean up all listeners on first trigger
    const dismiss = (e) => {
      if (!this.milestoneDialogActive) return;
      e.preventDefault();
      window.removeEventListener('keydown', dismiss);
      window.removeEventListener('touchstart', dismiss);
      window.removeEventListener('click', dismiss);
      this.dismissMilestoneDialog();
    };
    // Small delay so the triggering input doesn't instantly dismiss
    setTimeout(() => {
      if (!this.milestoneDialogActive) return; // already dismissed somehow
      window.addEventListener('keydown', dismiss);
      window.addEventListener('touchstart', dismiss);
      window.addEventListener('click', dismiss);
    }, 400);
  }

  dismissMilestoneDialog() {
    if (!this.milestoneDialogActive) return;
    this.milestoneDialogActive = false;
    document.getElementById('milestone-dialog').classList.remove('visible');
    if (this.milestoneDialogCallback) {
      this.milestoneDialogCallback();
      this.milestoneDialogCallback = null;
    }
  }

  generateCoins() {
    // Place exactly 2 coins between each pair of landmarks, evenly spaced
    const COINS_PER_SEGMENT = 2;
    const waypoints = [
      { x: 3, y: 8 }, { x: 9, y: 8 }, { x: 15, y: 8 },
      { x: 21, y: 8 }, { x: 27, y: 8 }, { x: 27, y: 15 },
      { x: 21, y: 15 }, { x: 15, y: 15 }, { x: 9, y: 15 },
      { x: 9, y: 24 }
    ];
    const coins = [];

    for (let i = 0; i < waypoints.length - 1; i++) {
      const from = waypoints[i];
      const to = waypoints[i + 1];
      const dx = to.x - from.x;
      const dy = to.y - from.y;

      for (let s = 1; s <= COINS_PER_SEGMENT; s++) {
        const t = s / (COINS_PER_SEGMENT + 1);
        const cx = from.x + dx * t;
        const cy = from.y + dy * t;

        const tileCol = Math.floor(cx);
        const tileRow = Math.floor(cy);
        if (this.worldMap.grid[tileRow] && this.worldMap.grid[tileRow][tileCol] === 'path') {
          coins.push({
            x: cx * TILE_SIZE + TILE_SIZE / 2,
            y: cy * TILE_SIZE + TILE_SIZE / 2,
            collected: false,
            collectAnim: 0
          });
        }
      }
    }

    this.coins = coins;
    this.totalCoins = coins.length;
    this.coinsCollected = 0;
  }

  updateCoins() {
    const pickupRadius = 20;
    for (const coin of this.coins) {
      if (coin.collected) {
        if (coin.collectAnim > 0) coin.collectAnim--;
        continue;
      }
      const dx = this.character.x - coin.x;
      const dy = this.character.y - coin.y;
      if (dx * dx + dy * dy < pickupRadius * pickupRadius) {
        coin.collected = true;
        coin.collectAnim = 15; // float-up animation frames
        this.coinsCollected++;
        this.character.jumpTimer = 12; // trigger jump
        this.playCoinSound();
      }
    }
  }

  // ---- Audio ----

  ensureAudio() {
    if (!this.audioCtx) {
      this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (this.audioCtx.state === 'suspended' && !this.muted) {
      this.audioCtx.resume();
    }
    return this.audioCtx;
  }

  // ---- Background Music ----

  stopMusic() {
    if (this.currentMusic) {
      clearInterval(this.currentMusic.intervalId);
      this.currentMusic.nodes.forEach(n => { try { n.stop(); } catch(e){} });
      this.currentMusic = null;
    }
  }

  startExploreMusic() {
    if (this.muted) return;
    if (this.currentMusic && this.currentMusic.type === 'explore') return;
    this.stopMusic();
    try {
      const ctx = this.ensureAudio();
      if (!this.musicGain) {
        this.musicGain = ctx.createGain();
        this.musicGain.connect(ctx.destination);
      }
      this.musicGain.gain.setValueAtTime(0.06, ctx.currentTime);

      const nodes = [];
      const bpm = 110;
      const beatLen = 60 / bpm;

      // Melody: gentle adventurous loop in C major pentatonic
      const melody = [
        523, 587, 659, 784, 659, 587, 523, 440,  // C5 D5 E5 G5 E5 D5 C5 A4
        523, 659, 784, 880, 784, 659, 523, 587,  // C5 E5 G5 A5 G5 E5 C5 D5
        440, 523, 587, 659, 523, 440, 392, 440,  // A4 C5 D5 E5 C5 A4 G4 A4
        523, 587, 659, 523, 440, 392, 440, 523,  // C5 D5 E5 C5 A4 G4 A4 C5
      ];

      // Bass: simple root notes, half-time
      const bass = [
        131, 131, 175, 175, 131, 131, 165, 165,  // C3 C3 F3 F3 C3 C3 E3 E3
        110, 110, 131, 131, 131, 131, 147, 147,  // A2 A2 C3 C3 C3 C3 D3 D3
      ];

      let melodyIdx = 0;
      let bassIdx = 0;
      let beat = 0;

      const playBeat = () => {
        const now = ctx.currentTime;

        // Melody note (square, soft)
        const mOsc = ctx.createOscillator();
        mOsc.type = 'square';
        mOsc.frequency.setValueAtTime(melody[melodyIdx % melody.length], now);
        const mGain = ctx.createGain();
        mGain.gain.setValueAtTime(0.5, now);
        mGain.gain.exponentialRampToValueAtTime(0.01, now + beatLen * 0.85);
        mOsc.connect(mGain);
        mGain.connect(this.musicGain);
        mOsc.start(now);
        mOsc.stop(now + beatLen * 0.9);
        nodes.push(mOsc);

        // Bass note (triangle, every 2 beats)
        if (beat % 2 === 0) {
          const bOsc = ctx.createOscillator();
          bOsc.type = 'triangle';
          bOsc.frequency.setValueAtTime(bass[bassIdx % bass.length], now);
          const bGain = ctx.createGain();
          bGain.gain.setValueAtTime(0.7, now);
          bGain.gain.exponentialRampToValueAtTime(0.01, now + beatLen * 1.8);
          bOsc.connect(bGain);
          bGain.connect(this.musicGain);
          bOsc.start(now);
          bOsc.stop(now + beatLen * 1.9);
          nodes.push(bOsc);
          bassIdx++;
        }

        // Light percussion: hi-hat noise on every beat
        const hatBuf = ctx.createBuffer(1, ctx.sampleRate * 0.03, ctx.sampleRate);
        const hatData = hatBuf.getChannelData(0);
        for (let i = 0; i < hatData.length; i++) hatData[i] = (Math.random() * 2 - 1);
        const hat = ctx.createBufferSource();
        hat.buffer = hatBuf;
        const hatGain = ctx.createGain();
        hatGain.gain.setValueAtTime(beat % 4 === 0 ? 0.3 : 0.12, now);
        hatGain.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
        hat.connect(hatGain);
        hatGain.connect(this.musicGain);
        hat.start(now);

        melodyIdx++;
        beat++;

        // Clean up old nodes (keep last 16)
        while (nodes.length > 16) nodes.shift();
      };

      const intervalId = setInterval(playBeat, beatLen * 1000);
      playBeat(); // start immediately
      this.currentMusic = { type: 'explore', intervalId, nodes };
    } catch (e) { /* silent fallback */ }
  }

  startBossMusic() {
    if (this.muted) return;
    if (this.currentMusic && this.currentMusic.type === 'boss') return;
    this.stopMusic();
    try {
      const ctx = this.ensureAudio();
      if (!this.musicGain) {
        this.musicGain = ctx.createGain();
        this.musicGain.connect(ctx.destination);
      }
      this.musicGain.gain.setValueAtTime(0.07, ctx.currentTime);

      const nodes = [];
      const bpm = 150;
      const beatLen = 60 / bpm;

      // Aggressive minor-key melody: E minor / diminished tension
      const melody = [
        330, 330, 392, 370, 330, 294, 330, 262,  // E4 E4 G4 F#4 E4 D4 E4 C4
        330, 370, 392, 440, 392, 370, 330, 294,  // E4 F#4 G4 A4 G4 F#4 E4 D4
        262, 294, 330, 294, 262, 247, 262, 330,  // C4 D4 E4 D4 C4 B3 C4 E4
        370, 392, 440, 494, 440, 392, 370, 330,  // F#4 G4 A4 B4 A4 G4 F#4 E4
      ];

      // Heavy bass: octave pumping in E minor
      const bass = [
        82, 82, 82, 82, 98, 98, 82, 82,     // E2 E2 E2 E2 G2 G2 E2 E2
        110, 110, 98, 98, 82, 82, 73, 73,   // A2 A2 G2 G2 E2 E2 D2 D2
      ];

      let melodyIdx = 0;
      let bassIdx = 0;
      let beat = 0;

      const playBeat = () => {
        const now = ctx.currentTime;

        // Lead: aggressive sawtooth
        const mOsc = ctx.createOscillator();
        mOsc.type = 'sawtooth';
        mOsc.frequency.setValueAtTime(melody[melodyIdx % melody.length], now);
        const mGain = ctx.createGain();
        mGain.gain.setValueAtTime(0.4, now);
        mGain.gain.exponentialRampToValueAtTime(0.01, now + beatLen * 0.7);
        mOsc.connect(mGain);
        mGain.connect(this.musicGain);
        mOsc.start(now);
        mOsc.stop(now + beatLen * 0.75);
        nodes.push(mOsc);

        // Heavy bass: every beat, sawtooth for grit
        if (beat % 2 === 0) {
          const bOsc = ctx.createOscillator();
          bOsc.type = 'sawtooth';
          bOsc.frequency.setValueAtTime(bass[bassIdx % bass.length], now);
          const bGain = ctx.createGain();
          bGain.gain.setValueAtTime(0.6, now);
          bGain.gain.exponentialRampToValueAtTime(0.01, now + beatLen * 1.8);
          bOsc.connect(bGain);
          bGain.connect(this.musicGain);
          bOsc.start(now);
          bOsc.stop(now + beatLen * 1.9);
          nodes.push(bOsc);
          bassIdx++;
        }

        // Percussion: kick on 1 & 3, snare on 2 & 4
        if (beat % 4 === 0 || beat % 4 === 2) {
          // Kick: low sine pitch-drop
          const kick = ctx.createOscillator();
          kick.type = 'sine';
          kick.frequency.setValueAtTime(150, now);
          kick.frequency.exponentialRampToValueAtTime(40, now + 0.08);
          const kGain = ctx.createGain();
          kGain.gain.setValueAtTime(0.5, now);
          kGain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
          kick.connect(kGain);
          kGain.connect(this.musicGain);
          kick.start(now);
          kick.stop(now + 0.12);
          nodes.push(kick);
        }
        if (beat % 4 === 1 || beat % 4 === 3) {
          // Snare: noise burst
          const sBuf = ctx.createBuffer(1, ctx.sampleRate * 0.06, ctx.sampleRate);
          const sData = sBuf.getChannelData(0);
          for (let i = 0; i < sData.length; i++) sData[i] = (Math.random() * 2 - 1);
          const snare = ctx.createBufferSource();
          snare.buffer = sBuf;
          const sGain = ctx.createGain();
          sGain.gain.setValueAtTime(0.35, now);
          sGain.gain.exponentialRampToValueAtTime(0.001, now + 0.06);
          snare.connect(sGain);
          sGain.connect(this.musicGain);
          snare.start(now);
        }

        // Hi-hat on every beat
        const hatBuf = ctx.createBuffer(1, ctx.sampleRate * 0.02, ctx.sampleRate);
        const hatData = hatBuf.getChannelData(0);
        for (let i = 0; i < hatData.length; i++) hatData[i] = (Math.random() * 2 - 1);
        const hat = ctx.createBufferSource();
        hat.buffer = hatBuf;
        const hatGain = ctx.createGain();
        hatGain.gain.setValueAtTime(0.2, now);
        hatGain.gain.exponentialRampToValueAtTime(0.001, now + 0.025);
        hat.connect(hatGain);
        hatGain.connect(this.musicGain);
        hat.start(now);

        melodyIdx++;
        beat++;
        while (nodes.length > 16) nodes.shift();
      };

      const intervalId = setInterval(playBeat, beatLen * 1000);
      playBeat();
      this.currentMusic = { type: 'boss', intervalId, nodes };
    } catch (e) { /* silent fallback */ }
  }

  playCoinSound() {
    if (this.muted) return;
    try {
      const ctx = this.ensureAudio();
      const now = ctx.currentTime;

      // Classic coin pickup: two quick ascending square-wave tones
      const osc1 = ctx.createOscillator();
      const osc2 = ctx.createOscillator();
      const gain = ctx.createGain();

      osc1.type = 'square';
      osc2.type = 'square';

      // First tone: B5, then second tone: E6 (a perfect fourth up)
      osc1.frequency.setValueAtTime(988, now);       // B5
      osc2.frequency.setValueAtTime(1319, now + 0.07); // E6

      gain.gain.setValueAtTime(0.12, now);
      gain.gain.setValueAtTime(0.12, now + 0.07);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);

      osc1.connect(gain);
      osc2.connect(gain);
      gain.connect(ctx.destination);

      osc1.start(now);
      osc1.stop(now + 0.07);
      osc2.start(now + 0.07);
      osc2.stop(now + 0.2);
    } catch (e) {
      // Audio not available — silent fallback
    }
  }

  playShippedSound() {
    if (this.muted) return;
    // 90s PC "quest complete" fanfare — ascending arpeggio with triumph chord
    try {
      const ctx = this.ensureAudio();
      const now = ctx.currentTime;
      const gain = ctx.createGain();
      gain.connect(ctx.destination);
      gain.gain.setValueAtTime(0.10, now);
      gain.gain.setValueAtTime(0.10, now + 0.45);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);

      // Quick ascending arpeggio: C5 → E5 → G5 → C6 (major triad fanfare)
      const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
      const noteLen = 0.09;
      notes.forEach((freq, i) => {
        const osc = ctx.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(freq, now + i * noteLen);
        osc.connect(gain);
        osc.start(now + i * noteLen);
        osc.stop(now + i * noteLen + noteLen * 1.2);
      });

      // Final triumph chord: C5 + E5 + G5 held together
      const chordStart = now + notes.length * noteLen;
      [523, 659, 784].forEach(freq => {
        const osc = ctx.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(freq, chordStart);
        osc.connect(gain);
        osc.start(chordStart);
        osc.stop(chordStart + 0.35);
      });
    } catch (e) { /* silent fallback */ }
  }

  playUpcomingSound() {
    if (this.muted) return;
    // Retro "scroll unroll" — quick descending triplet, like opening a quest log
    try {
      const ctx = this.ensureAudio();
      const now = ctx.currentTime;
      const gain = ctx.createGain();
      gain.connect(ctx.destination);
      gain.gain.setValueAtTime(0.10, now);
      gain.gain.setValueAtTime(0.10, now + 0.22);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);

      // Three quick descending notes: G5 → E5 → C5 (minor feel, mysterious)
      const notes = [784, 659, 523];
      const step = 0.07;
      notes.forEach((freq, i) => {
        const osc = ctx.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(freq, now + i * step);
        osc.connect(gain);
        osc.start(now + i * step);
        osc.stop(now + i * step + step * 1.2);
      });
    } catch (e) { /* silent fallback */ }
  }

  playLevelUpSound() {
    if (this.muted) return;
    // 90s PC power-up: rapid ascending scale into a bright held chord
    try {
      const ctx = this.ensureAudio();
      const now = ctx.currentTime;
      const gain = ctx.createGain();
      gain.connect(ctx.destination);
      gain.gain.setValueAtTime(0.11, now);
      gain.gain.setValueAtTime(0.13, now + 0.5);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 1.1);

      // Fast ascending scale: C5 D5 E5 F5 G5 A5 B5 C6
      const scale = [523, 587, 659, 698, 784, 880, 988, 1047];
      const step = 0.055;
      scale.forEach((freq, i) => {
        const osc = ctx.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(freq, now + i * step);
        osc.connect(gain);
        osc.start(now + i * step);
        osc.stop(now + i * step + step * 1.3);
      });

      // Hold a bright major chord: C6 + E6 + G6
      const chordStart = now + scale.length * step;
      [1047, 1319, 1568].forEach(freq => {
        const osc = ctx.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(freq, chordStart);
        osc.connect(gain);
        osc.start(chordStart);
        osc.stop(chordStart + 0.5);
      });
      // Sparkle overtone
      const sparkle = ctx.createOscillator();
      sparkle.type = 'sine';
      sparkle.frequency.setValueAtTime(2093, chordStart); // C7
      const sGain = ctx.createGain();
      sGain.gain.setValueAtTime(0.04, chordStart);
      sGain.gain.exponentialRampToValueAtTime(0.001, chordStart + 0.5);
      sparkle.connect(sGain);
      sGain.connect(ctx.destination);
      sparkle.start(chordStart);
      sparkle.stop(chordStart + 0.5);
    } catch (e) { /* silent fallback */ }
  }

  playBossEncounterSound() {
    if (this.muted) return;
    // Ominous 90s boss intro: low rumbling power chord + descending doom motif
    try {
      const ctx = this.ensureAudio();
      const now = ctx.currentTime;
      const gain = ctx.createGain();
      gain.connect(ctx.destination);
      gain.gain.setValueAtTime(0.13, now);
      gain.gain.setValueAtTime(0.13, now + 0.8);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 1.5);

      // Low power chord: E2 + B2 (heavy, ominous)
      [82, 123].forEach(freq => {
        const osc = ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(freq, now);
        osc.connect(gain);
        osc.start(now);
        osc.stop(now + 0.6);
      });

      // Descending doom motif: E4 → D#4 → D4 → C#4 → C4
      const doom = [330, 311, 294, 277, 262];
      const dStep = 0.12;
      const dStart = now + 0.15;
      doom.forEach((freq, i) => {
        const osc = ctx.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(freq, dStart + i * dStep);
        osc.connect(gain);
        osc.start(dStart + i * dStep);
        osc.stop(dStart + i * dStep + dStep * 1.4);
      });

      // Final low stab: C3 + G3 (minor power chord)
      const stabStart = dStart + doom.length * dStep;
      [131, 196].forEach(freq => {
        const osc = ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(freq, stabStart);
        const stabGain = ctx.createGain();
        stabGain.gain.setValueAtTime(0.12, stabStart);
        stabGain.gain.exponentialRampToValueAtTime(0.001, stabStart + 0.5);
        osc.connect(stabGain);
        stabGain.connect(ctx.destination);
        osc.start(stabStart);
        osc.stop(stabStart + 0.5);
      });
    } catch (e) { /* silent fallback */ }
  }

  playArrowHitSound() {
    if (this.muted) return;
    // Retro hitmarker: sharp noise burst + quick pitch-down thwack
    try {
      const ctx = this.ensureAudio();
      const now = ctx.currentTime;

      // Noise burst (white noise through band-pass for that crunchy hit)
      const bufferSize = ctx.sampleRate * 0.06;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
      }
      const noise = ctx.createBufferSource();
      noise.buffer = buffer;
      const noiseGain = ctx.createGain();
      noiseGain.gain.setValueAtTime(0.15, now);
      noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.06);
      noise.connect(noiseGain);
      noiseGain.connect(ctx.destination);
      noise.start(now);

      // Pitch-down thwack: square wave from A5 dropping to A3
      const osc = ctx.createOscillator();
      osc.type = 'square';
      osc.frequency.setValueAtTime(880, now);
      osc.frequency.exponentialRampToValueAtTime(220, now + 0.08);
      const oscGain = ctx.createGain();
      oscGain.gain.setValueAtTime(0.10, now);
      oscGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
      osc.connect(oscGain);
      oscGain.connect(ctx.destination);
      osc.start(now);
      osc.stop(now + 0.1);
    } catch (e) { /* silent fallback */ }
  }

  playBossDefeatedSound() {
    if (this.muted) return;
    // Epic 90s victory fanfare: triumphant ascending arpeggios into major chord explosion
    try {
      const ctx = this.ensureAudio();
      const now = ctx.currentTime;
      const gain = ctx.createGain();
      gain.connect(ctx.destination);
      gain.gain.setValueAtTime(0.11, now);
      gain.gain.setValueAtTime(0.13, now + 1.0);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 2.0);

      // First arpeggio: G major ascending — G4 B4 D5 G5
      const arp1 = [392, 494, 587, 784];
      const s = 0.1;
      arp1.forEach((freq, i) => {
        const osc = ctx.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(freq, now + i * s);
        osc.connect(gain);
        osc.start(now + i * s);
        osc.stop(now + i * s + s * 1.3);
      });

      // Second arpeggio: C major ascending — C5 E5 G5 C6
      const arp2Start = now + arp1.length * s + 0.05;
      const arp2 = [523, 659, 784, 1047];
      arp2.forEach((freq, i) => {
        const osc = ctx.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(freq, arp2Start + i * s);
        osc.connect(gain);
        osc.start(arp2Start + i * s);
        osc.stop(arp2Start + i * s + s * 1.3);
      });

      // Final held victory chord: C5 + E5 + G5 + C6 (big and bright)
      const chordStart = arp2Start + arp2.length * s;
      [523, 659, 784, 1047].forEach(freq => {
        const osc = ctx.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(freq, chordStart);
        osc.connect(gain);
        osc.start(chordStart);
        osc.stop(chordStart + 0.8);
      });

      // High sparkle cascade
      const sparkles = [2093, 1568, 2093]; // C7, G6, C7
      sparkles.forEach((freq, i) => {
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        const sGain = ctx.createGain();
        sGain.gain.setValueAtTime(0.04, chordStart + i * 0.15);
        sGain.gain.exponentialRampToValueAtTime(0.001, chordStart + i * 0.15 + 0.4);
        osc.frequency.setValueAtTime(freq, chordStart + i * 0.15);
        osc.connect(sGain);
        sGain.connect(ctx.destination);
        osc.start(chordStart + i * 0.15);
        osc.stop(chordStart + i * 0.15 + 0.4);
      });
    } catch (e) { /* silent fallback */ }
  }

  drawCoins(ctx, cx, cy) {
    const hasFrames = this.coinFrames && this.coinFrames.length > 0;
    const frameCount = hasFrames ? this.coinFrames.length : 8;
    const COIN_SCALE = 1.0; // Round coins are already properly sized

    for (const coin of this.coins) {
      if (coin.collected && coin.collectAnim <= 0) continue;

      const sx = coin.x - cx;
      const sy = coin.y - cy;

      if (coin.collected) {
        // Float-up and fade out animation
        const progress = 1 - coin.collectAnim / 15;
        ctx.globalAlpha = 1 - progress;
        const floatY = sy - progress * 24;

        if (hasFrames) {
          const frame = this.coinFrames[0]; // show face on collect
          const w = frame.width * COIN_SCALE * (1 - progress * 0.3);
          const h = frame.height * COIN_SCALE * (1 - progress * 0.3);
          ctx.drawImage(frame, sx - w / 2, floatY - h / 2, w, h);
        } else {
          ctx.fillStyle = '#f0c040';
          ctx.fillRect(sx - 4, floatY - 5, 8, 10);
        }

        // +1 text
        ctx.fillStyle = '#f0d060';
        ctx.fillRect(sx + 6, floatY - 10, 1, 5);
        ctx.fillRect(sx + 4, floatY - 8, 5, 1);
        ctx.fillRect(sx + 10, floatY - 10, 2, 5);
        ctx.fillRect(sx + 9, floatY - 10, 1, 1);

        ctx.globalAlpha = 1;
      } else {
        const hover = Math.sin(this.time * 0.05) * 2;

        // Classic pixel rotation: all coins spin in sync
        const frameIdx = Math.floor(this.time * 0.12) % frameCount;

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fillRect(sx - 5, sy + 8 + hover, 10, 3);

        if (hasFrames) {
          const frame = this.coinFrames[frameIdx];
          const w = frame.width * COIN_SCALE;
          const h = frame.height * COIN_SCALE;
          ctx.drawImage(frame, sx - w / 2, sy - h / 2 + hover, w, h);

          // Bright shine when showing face (frame 0 or near it)
          if (frameIdx === 0 || frameIdx === frameCount - 1) {
            ctx.globalAlpha = 0.4;
            ctx.fillStyle = '#fff8d0';
            ctx.fillRect(sx - 2, sy - 4 + hover, 3, 3);
            ctx.globalAlpha = 1;
          }
        } else {
          // Fallback procedural spinning coin
          const spinScale = Math.abs(Math.cos((frameIdx / frameCount) * Math.PI));
          const spinW = spinScale * 8 + 2;
          const coinH = 10;
          ctx.fillStyle = '#a07010';
          ctx.fillRect(sx - spinW / 2 - 1, sy - coinH / 2 + hover - 1, spinW + 2, coinH + 2);
          ctx.fillStyle = '#d4a020';
          ctx.fillRect(sx - spinW / 2, sy - coinH / 2 + hover, spinW, coinH);
          if (spinW > 4) {
            ctx.fillStyle = '#f0d060';
            ctx.fillRect(sx - spinW / 2 + 1, sy - coinH / 2 + 1 + hover, spinW - 2, 3);
            ctx.fillStyle = '#fff8d0';
            ctx.fillRect(sx - spinW / 2 + 1, sy - coinH / 2 + 1 + hover, 2, 2);
          }
          ctx.fillStyle = '#9a6808';
          ctx.fillRect(sx - spinW / 2, sy + coinH / 2 - 1 + hover, spinW, 1);
        }
      }
    }
  }

  startDragonFight() {
    if (this.dragonFightActive) return; // Already in fight — don't restart
    this.dragonFightActive = true;
    this.gamePhase = 'dragon_fight';
    this.dragonMaxHP = 40;
    this.dragonHP = this.dragonMaxHP; // ~5 hits at 8 damage each
    this.arrowsFired = [];
    this.dragonHitTimer = 0;
    // Stop all character movement — Bard stands still during boss fight
    this.cancelAutoMove(true);
    this.character.moving = false;
    this.playBossEncounterSound();
    // Switch to boss music
    setTimeout(() => this.startBossMusic(), 1200); // after encounter SFX finishes
    // Close any info panel and show the slay button
    this.closePanel();
    document.getElementById('slay-button').classList.add('visible');
  }

  fireDragonArrow() {
    const dragon = ROADMAP_ITEMS.find(i => i.id === 'milestone2');
    const dx = dragon.mapX * TILE_SIZE + 48 - this.character.x;
    const dy = dragon.mapY * TILE_SIZE + 48 - this.character.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    this.arrowsFired.push({
      x: this.character.x,
      y: this.character.y - 8,
      vx: (dx / dist) * 8,
      vy: (dy / dist) * 8,
      life: 60
    });
  }

  updateDragonFight() {
    if (!this.dragonFightActive) return;

    // NO auto-fire — player clicks the slay button

    // Update arrows
    const dragon = ROADMAP_ITEMS.find(i => i.id === 'milestone2');
    const dragonX = dragon.mapX * TILE_SIZE + 48;
    const dragonY = dragon.mapY * TILE_SIZE + 48;

    this.arrowsFired = this.arrowsFired.filter(arrow => {
      arrow.x += arrow.vx;
      arrow.y += arrow.vy;
      arrow.life--;

      // Hit detection
      const dist = Math.sqrt((arrow.x - dragonX) ** 2 + (arrow.y - dragonY) ** 2);
      if (dist < 40) {
        this.dragonHP -= 8;
        this.dragonHitTimer = 10;
        this.hitFlashTimer = 6;
        this.playArrowHitSound();
        this.particles.emit(dragonX, dragonY, 10, {
          colors: ['#ff4040', '#ff8040', '#ffff40'],
          speed: 5,
          gravity: 0.1
        });
        return false;
      }

      return arrow.life > 0;
    });

    // Dragon defeated
    if (this.dragonHP <= 0 && !this.dragonSlain) {
      this.dragonSlain = true;
      this.dragonFightActive = false;
      this.gamePhase = 'victory';
      this.victoryTimer = 120; // 2 seconds until victory screen
      this.victoryFlashTimer = 30;
      this.stopMusic();
      this.playBossDefeatedSound();
      // Hide slay button
      document.getElementById('slay-button').classList.remove('visible');
      // Victory particles
      for (let i = 0; i < 5; i++) {
        setTimeout(() => {
          this.particles.emit(dragonX + (Math.random()-0.5)*60, dragonY + (Math.random()-0.5)*60, 30, {
            colors: ['#f0c040', '#ff8020', '#ff4040', '#fff', '#40e040'],
            speed: 8,
            upward: true,
            life: 80,
            gravity: -0.05
          });
        }, i * 200);
      }
      this.showMilestoneBanner('DRAGON SLAIN!\nTHE QUEST IS COMPLETE');
    }
  }

  drawArrows(ctx) {
    for (const arrow of this.arrowsFired) {
      const sx = arrow.x - this.cameraX;
      const sy = arrow.y - this.cameraY;
      const angle = Math.atan2(arrow.vy, arrow.vx);
      ctx.save();
      ctx.translate(sx, sy);
      ctx.rotate(angle);
      // Arrow shaft
      ctx.fillStyle = '#b08040';
      ctx.fillRect(-8, -1, 16, 2);
      // Arrowhead (metal tip)
      ctx.fillStyle = '#888';
      ctx.fillRect(6, -2, 4, 1);
      ctx.fillRect(7, -1, 4, 2);
      ctx.fillRect(6, 1, 4, 1);
      ctx.fillStyle = '#aaa';
      ctx.fillRect(8, -1, 3, 2);
      // Fletching (red feathers at back)
      ctx.fillStyle = '#cc3030';
      ctx.fillRect(-8, -3, 4, 2);
      ctx.fillRect(-8, 1, 4, 2);
      ctx.fillStyle = '#a02020';
      ctx.fillRect(-7, -2, 2, 1);
      ctx.fillRect(-7, 1, 2, 1);
      ctx.restore();
    }
  }

  update() {
    if (!this.loaded) return;

    this.time++;
    this.itemGlowPhase += 0.03;

    // Pause game logic while milestone dialog is showing
    if (this.milestoneDialogActive) {
      this.particles.update();
      return;
    }

    // === Opening scene state machine ===
    if (this.gamePhase === 'opening_dragon') {
      this.openingTimer++;
      // Show dragon speech bubble via typewriter effect
      this.openingTextIndex = Math.min(this.openingText.length, Math.floor(this.openingTimer / 2));
      // Dragon laugh animation (oscillating particles)
      if (this.openingTimer % 20 === 0) {
        const dragon = ROADMAP_ITEMS.find(i => i.id === 'milestone2');
        this.particles.emit(
          dragon.mapX * TILE_SIZE + 48 + (Math.random() - 0.5) * 40,
          dragon.mapY * TILE_SIZE + 20,
          5,
          { colors: ['#f08020', '#f0c040', '#ff4020'], speed: 3, life: 30, upward: true, gravity: -0.03 }
        );
      }
      // After ~4 seconds, pan to Bard
      if (this.openingTimer > 240) {
        this.gamePhase = 'opening_pan';
        this.openingTimer = 0;
      }
      this.particles.update();
      return;
    }

    if (this.gamePhase === 'opening_pan') {
      this.openingTimer++;
      // Smoothly pan camera from dragon to Bard's start position
      const viewW = this.width / this.zoom;
      const viewH = this.height / this.zoom;
      const bardX = this.character.x - viewW / 2;
      const bardY = this.character.y - viewH / 2;
      this.cameraX += (bardX - this.cameraX) * 0.03;
      this.cameraY += (bardY - this.cameraY) * 0.03;
      this.particles.update();
      // Once camera is close enough to Bard, show intro scroll
      const dist = Math.abs(this.cameraX - bardX) + Math.abs(this.cameraY - bardY);
      if (dist < 5 || this.openingTimer > 180) {
        this.cameraX = bardX;
        this.cameraY = bardY;
        this.gamePhase = 'opening_bard';
        document.getElementById('intro-backdrop').classList.add('visible');
        document.getElementById('intro-scroll').classList.add('visible');
      }
      return;
    }

    if (this.gamePhase === 'opening_bard') {
      // Waiting for player to click GO — no game logic runs
      this.particles.update();
      return;
    }

    // === Victory timer ===
    if (this.gamePhase === 'victory') {
      if (this.victoryFlashTimer > 0) this.victoryFlashTimer--;
      if (this.victoryTimer > 0) {
        this.victoryTimer--;
        if (this.victoryTimer === 0) {
          document.getElementById('victory-screen').classList.add('visible');
        }
      }
      // Still update particles and character for background animation
    }

    // Tap-to-move: convert move target into directional keys
    if (this.moveTarget) {
      const dx = this.moveTarget.x - this.character.x;
      const dy = this.moveTarget.y - this.character.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < 8) {
        // Arrived at one waypoint: continue route or stop.
        if (this.pathQueue.length > 0) {
          this.moveTarget = this.pathQueue.shift();
          this.lastAutoMoveDistance = null;
          this.autoMoveStuckFrames = 0;
        } else {
          this.cancelAutoMove(true);
        }
      } else {
        // Set directional keys toward target
        const deadzone = 0.3; // prevents jittery micro-movements
        this.keys.up = dy < -dist * deadzone;
        this.keys.down = dy > dist * deadzone;
        this.keys.left = dx < -dist * deadzone;
        this.keys.right = dx > dist * deadzone;

        // Bail out if distance is not improving (prevents endless "push in one direction").
        if (this.lastAutoMoveDistance !== null && dist >= this.lastAutoMoveDistance - 0.2) {
          this.autoMoveStuckFrames++;
          if (this.autoMoveStuckFrames > 28) {
            if (this.pathQueue.length > 0) {
              this.moveTarget = this.pathQueue.shift();
              this.lastAutoMoveDistance = null;
              this.autoMoveStuckFrames = 0;
            } else {
              this.cancelAutoMove(true);
            }
          }
        } else {
          this.autoMoveStuckFrames = 0;
        }
        this.lastAutoMoveDistance = dist;
      }
    }

    // Fade tap indicator
    if (this.tapIndicator) {
      this.tapIndicator.alpha -= 0.02;
      if (this.tapIndicator.alpha <= 0) this.tapIndicator = null;
    }

    // Update character
    this.character.update(this.keys, this.worldMap);

    // Camera follow — account for zoom (viewport is smaller in world coords)
    const viewW = this.width / this.zoom;
    const viewH = this.height / this.zoom;
    this.targetCameraX = this.character.x - viewW / 2;
    this.targetCameraY = this.character.y - viewH / 2;

    // Clamp camera
    const maxCX = MAP_COLS * TILE_SIZE - viewW;
    const maxCY = MAP_ROWS * TILE_SIZE - viewH;
    this.targetCameraX = Math.max(0, Math.min(this.targetCameraX, maxCX));
    this.targetCameraY = Math.max(0, Math.min(this.targetCameraY, maxCY));

    this.cameraX += (this.targetCameraX - this.cameraX) * CAMERA_SMOOTH;
    this.cameraY += (this.targetCameraY - this.cameraY) * CAMERA_SMOOTH;

    // Auto-show info panel and milestones on proximity
    // During dragon fight, skip normal proximity logic — boss battle owns the UI
    if (this.gamePhase !== 'dragon_fight') {
      const nearbyItem = this.character.getNearbyItem(60);
      const nearbyPitfall = nearbyItem ? null : this.getNearbyPitfall(56);
      if (nearbyItem) {
        if (nearbyItem !== this.activePanel) {
          this.interactWithItem(nearbyItem);
        }
      } else if (nearbyPitfall) {
        if (nearbyPitfall !== this.activePanel) {
          this.interactWithPitfall(nearbyPitfall);
        }
      } else if (this.activePanel) {
        this.closePanel();
      }
    }

    // Milestone banner timer
    if (this.milestoneBannerTimer > 0) {
      this.milestoneBannerTimer--;
      if (this.milestoneBannerTimer === 0) {
        document.getElementById('milestone-banner').classList.remove('visible');
      }
    }

    // Coin collection
    this.updateCoins();

    // Dragon fight
    this.updateDragonFight();

    // Particles (only for dragon fight effects)
    this.particles.update();

    // Update quest progress
    const visited = this.character.visitedItems.size;
    const total = ROADMAP_ITEMS.filter(i => i.status !== 'milestone').length;
    document.getElementById('quest-progress').textContent =
      `Discoveries: ${visited}/${total}` + (this.dragonSlain ? ' | DRAGON SLAIN' : '');
    document.getElementById('coin-counter').textContent =
      `Coins: ${this.coinsCollected}/${this.totalCoins}`;
  }

  draw() {
    if (!this.loaded) return;

    const ctx = this.ctx;
    const cx = Math.round(this.cameraX);
    const cy = Math.round(this.cameraY);
    const viewW = this.width / this.zoom;
    const viewH = this.height / this.zoom;

    // Clear at full resolution
    ctx.fillStyle = '#0a0a1a';
    ctx.fillRect(0, 0, this.width, this.height);

    // Apply zoom
    ctx.save();
    ctx.scale(this.zoom, this.zoom);

    // Calculate visible tile range (in zoomed view)
    const startCol = Math.max(0, Math.floor(cx / TILE_SIZE) - 1);
    const endCol = Math.min(this.worldMap.cols - 1, Math.ceil((cx + viewW) / TILE_SIZE) + 1);
    const startRow = Math.max(0, Math.floor(cy / TILE_SIZE) - 1);
    const endRow = Math.min(this.worldMap.rows - 1, Math.ceil((cy + viewH) / TILE_SIZE) + 1);

    // Draw tiles with Wang autotiling for all terrain types
    for (let row = startRow; row <= endRow; row++) {
      for (let col = startCol; col <= endCol; col++) {
        const tile = this.worldMap.grid[row][col];
        const drawX = col * TILE_SIZE - cx;
        const drawY = row * TILE_SIZE - cy;

        // Base grass tile always drawn first
        const baseTile = this.wangGrassPath[0];
        if (baseTile) ctx.drawImage(baseTile, drawX, drawY);

        // For grass tiles: draw all Wang transitions (shows edges of adjacent terrains).
        // For non-grass tiles: only draw this tile's own terrain Wang.
        // This prevents path's opaque grass pixels from overwriting stone/volcanic, etc.
        if (tile === 'grass') {
          const darkWang = this.getWangIndex(col, row, 'darkGrass');
          const stoneWang = this.getWangIndex(col, row, 'stone');
          const volcanicWang = this.getWangIndex(col, row, 'volcanic');
          const waterWang = this.getWangIndex(col, row, 'water');
          const pathWang = this.getWangIndex(col, row, 'path');
          if (darkWang > 0 && this.wangGrassDark[darkWang])
            ctx.drawImage(this.wangGrassDark[darkWang], drawX, drawY);
          if (stoneWang > 0 && this.wangGrassStone[stoneWang])
            ctx.drawImage(this.wangGrassStone[stoneWang], drawX, drawY);
          if (volcanicWang > 0 && this.wangGrassVolcanic[volcanicWang])
            ctx.drawImage(this.wangGrassVolcanic[volcanicWang], drawX, drawY);
          if (waterWang > 0 && this.wangGrassWater[waterWang])
            ctx.drawImage(this.wangGrassWater[waterWang], drawX, drawY);
          if (pathWang > 0 && this.wangGrassPath[pathWang])
            ctx.drawImage(this.wangGrassPath[pathWang], drawX, drawY);
        } else if (tile === 'darkGrass') {
          const darkWang = this.getWangIndex(col, row, 'darkGrass');
          if (darkWang > 0 && this.wangGrassDark[darkWang])
            ctx.drawImage(this.wangGrassDark[darkWang], drawX, drawY);
        } else if (tile === 'stone') {
          const stoneWang = this.getWangIndex(col, row, 'stone');
          if (stoneWang > 0 && this.wangGrassStone[stoneWang])
            ctx.drawImage(this.wangGrassStone[stoneWang], drawX, drawY);
        } else if (tile === 'volcanic') {
          const volcanicWang = this.getWangIndex(col, row, 'volcanic');
          if (volcanicWang > 0 && this.wangGrassVolcanic[volcanicWang])
            ctx.drawImage(this.wangGrassVolcanic[volcanicWang], drawX, drawY);
          // Path→volcanic overlay: show path edges on volcanic tiles near path
          // path_volcanic tileset has lower=path, upper=volcanic; Wang bits encode 1=upper=volcanic
          // getWangIndex(col,row,'path') gives 1 where path detected, so complement (15-x) to get correct tileset index
          const pvPathWang = this.getWangIndex(col, row, 'path');
          if (pvPathWang > 0) {
            const pvIdx = 15 - pvPathWang;
            if (pvIdx > 0 && this.wangPathVolcanic && this.wangPathVolcanic[pvIdx])
              ctx.drawImage(this.wangPathVolcanic[pvIdx], drawX, drawY);
          }
        } else if (tile === 'water') {
          const waterWang = this.getWangIndex(col, row, 'water');
          if (waterWang > 0 && this.wangGrassWater[waterWang])
            ctx.drawImage(this.wangGrassWater[waterWang], drawX, drawY);
        } else if (tile === 'path') {
          const pathWang = this.getWangIndex(col, row, 'path');
          if (pathWang > 0 && this.wangGrassPath[pathWang])
            ctx.drawImage(this.wangGrassPath[pathWang], drawX, drawY);
        }
      }
    }


    // Animate water shimmer
    if (this.time % 40 < 20) {
      ctx.fillStyle = 'rgba(100,160,255,0.1)';
      for (let row = startRow; row <= endRow; row++) {
        for (let col = startCol; col <= endCol; col++) {
          if (this.worldMap.grid[row][col] === 'water') {
            ctx.fillRect(col * TILE_SIZE - cx, row * TILE_SIZE - cy, TILE_SIZE, TILE_SIZE);
          }
        }
      }
    }

    // Draw path direction dots (breadcrumbs following right-angle path)
    ctx.globalAlpha = 0.25 + Math.sin(this.time * 0.04) * 0.1;
    ctx.fillStyle = '#f0d080';
    // Build waypoints matching the winding path
    const breadcrumbWaypoints = [
      { x: 3, y: 8 },    // start
      { x: 9, y: 8 },    // item 1
      { x: 15, y: 8 },   // item 2
      { x: 21, y: 8 },   // item 3
      { x: 27, y: 8 },   // milestone1
      { x: 27, y: 15 },  // item 4
      { x: 21, y: 15 },  // item 5
      { x: 15, y: 15 },  // item 6
      { x: 9, y: 15 },   // item 7
      { x: 9, y: 24 },   // dragon
    ].map(p => ({ x: p.x * TILE_SIZE + TILE_SIZE/2, y: p.y * TILE_SIZE + TILE_SIZE/2 }));

    for (let i = 0; i < breadcrumbWaypoints.length - 1; i++) {
      const from = breadcrumbWaypoints[i];
      const to = breadcrumbWaypoints[i + 1];
      const dx = to.x - from.x;
      const dy = to.y - from.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const dots = Math.floor(dist / 40);
      for (let d = 1; d < dots; d++) {
        const t = d / dots;
        const px = from.x + dx * t - cx;
        const py = from.y + dy * t - cy;
        ctx.fillRect(Math.round(px) - 2, Math.round(py) - 2, 4, 4);
      }
    }
    ctx.globalAlpha = 1;

    // Draw zone section labels on the terrain
    this.drawZoneLabels(ctx, cx, cy);

    // Draw coins on path
    this.drawCoins(ctx, cx, cy);

    // Draw decorations (behind character based on y-sort)
    const charY = this.character.y;
    for (const deco of this.worldMap.decorations) {
      const decoWorldY = deco.y * TILE_SIZE + TILE_SIZE;
      if (decoWorldY < charY + 4) {
        this.drawDecoration(ctx, deco, cx, cy);
      }
    }

    // Draw roadmap items (behind character)
    for (const item of ROADMAP_ITEMS) {
      const itemWorldY = item.mapY * TILE_SIZE + TILE_SIZE;
      if (itemWorldY < charY + 4) {
        this.drawRoadmapItem(ctx, item, cx, cy);
      }
    }

    // Draw pitfall markers (behind character)
    for (const pitfall of PITFALLS) {
      const pitfallWorldY = pitfall.mapY * TILE_SIZE + TILE_SIZE;
      if (pitfallWorldY < charY + 4) {
        this.drawPitfall(ctx, pitfall, cx, cy);
      }
    }

    // Draw character
    this.character.draw(ctx, cx, cy);

    // Draw decorations (in front of character)
    for (const deco of this.worldMap.decorations) {
      const decoWorldY = deco.y * TILE_SIZE + TILE_SIZE;
      if (decoWorldY >= charY + 4) {
        this.drawDecoration(ctx, deco, cx, cy);
      }
    }

    // Draw roadmap items (in front of character)
    for (const item of ROADMAP_ITEMS) {
      const itemWorldY = item.mapY * TILE_SIZE + TILE_SIZE;
      if (itemWorldY >= charY + 4) {
        this.drawRoadmapItem(ctx, item, cx, cy);
      }
    }

    // Draw pitfall markers (in front of character)
    for (const pitfall of PITFALLS) {
      const pitfallWorldY = pitfall.mapY * TILE_SIZE + TILE_SIZE;
      if (pitfallWorldY >= charY + 4) {
        this.drawPitfall(ctx, pitfall, cx, cy);
      }
    }

    // Draw doctor NPCs (celebrating)
    this.drawDoctors(ctx, cx, cy);

    // Draw arrows
    this.drawArrows(ctx);

    // Draw particles on top (dragon fight only)
    this.particles.draw(ctx, cx, cy);

    // Draw dragon speech bubble during opening
    this.drawDragonSpeech(ctx, cx, cy);

    // Draw item labels (in world space)
    this.drawItemLabels(ctx, cx, cy);

    // Draw tap-to-move indicator
    if (this.tapIndicator) {
      const ti = this.tapIndicator;
      const ix = ti.x - cx;
      const iy = ti.y - cy;
      const pulse = Math.sin(this.time * 0.15) * 2;
      const indicatorColor = ti.blocked ? '#d04040' : '#f0c040';
      ctx.globalAlpha = ti.alpha * 0.6;
      ctx.strokeStyle = indicatorColor;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(ix, iy, 6 + pulse, 0, Math.PI * 2);
      ctx.stroke();
      // Inner dot
      ctx.fillStyle = indicatorColor;
      ctx.globalAlpha = ti.alpha * 0.8;
      ctx.beginPath();
      ctx.arc(ix, iy, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // End zoom context
    ctx.restore();

    // --- HUD elements drawn at screen resolution (no zoom) ---

    // Hit flash overlay (dragon fight feedback)
    if (this.hitFlashTimer > 0) {
      this.hitFlashTimer--;
      const alpha = (this.hitFlashTimer / 6) * 0.25;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#ff4040';
      ctx.fillRect(0, 0, this.width, this.height);
      ctx.restore();
    }

    // Victory flash (golden glow when dragon slain)
    if (this.victoryFlashTimer > 0) {
      const alpha = (this.victoryFlashTimer / 30) * 0.4;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#f0c040';
      ctx.fillRect(0, 0, this.width, this.height);
      ctx.restore();
    }

    // Draw dragon HP bar (responsive)
    if (this.dragonFightActive) {
      const barW = Math.min(300, this.width * 0.6);
      const barH = Math.min(36, this.height * 0.05);
      const barX = this.width / 2 - barW / 2;
      const barY = Math.min(112, this.height * 0.14);
      const fontSize = Math.max(10, Math.min(16, this.width * 0.02));

      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(barX - 2, barY - 2, barW + 4, barH + 4);
      ctx.fillStyle = '#600';
      ctx.fillRect(barX, barY, barW, barH);
      const hpFrac = Math.max(0, this.dragonHP / this.dragonMaxHP);
      ctx.fillStyle = '#c03030';
      ctx.fillRect(barX, barY, hpFrac * barW, barH);
      ctx.fillStyle = '#e04040';
      ctx.fillRect(barX, barY, hpFrac * barW, barH * 0.4);

      ctx.font = `${fontSize}px "Press Start 2P"`;
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.fillText('THE DRAGON', this.width / 2, barY - 10);
      ctx.textAlign = 'start';
    }

    // Update minimap
    if (this.time % 10 === 0) {
      this.updateMinimapDot();
    }
  }

  drawZoneLabels(ctx, cx, cy) {
    // Section 1: Foundation (shipped) — top row
    const sec1X = 15 * TILE_SIZE - cx;
    const sec1Y = 5 * TILE_SIZE - cy;
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.font = '12px "Press Start 2P"';
    ctx.fillStyle = '#40e040';
    ctx.textAlign = 'center';
    ctx.fillText('FOUNDATION', sec1X, sec1Y);
    ctx.font = '6px "Press Start 2P"';
    ctx.fillText('Shipped & Conquered', sec1X, sec1Y + 20);
    ctx.restore();

    // Section 2: Power-Ups (upcoming) — second row
    const sec2X = 18 * TILE_SIZE - cx;
    const sec2Y = 13 * TILE_SIZE - cy;
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.font = '12px "Press Start 2P"';
    ctx.fillStyle = '#f0c040';
    ctx.textAlign = 'center';
    ctx.fillText('POWER-UPS', sec2X, sec2Y);
    ctx.font = '6px "Press Start 2P"';
    ctx.fillText('On the Roadmap', sec2X, sec2Y + 20);
    ctx.restore();

    // Dragon Lair label
    const sec3X = 9 * TILE_SIZE - cx;
    const sec3Y = 21 * TILE_SIZE - cy;
    ctx.save();
    ctx.globalAlpha = 0.15;
    ctx.font = '10px "Press Start 2P"';
    ctx.fillStyle = '#c03030';
    ctx.textAlign = 'center';
    ctx.fillText('DRAGON LAIR', sec3X, sec3Y);
    ctx.restore();
  }

  drawDecoration(ctx, deco, cx, cy) {
    const sprite = this.decos[deco.type];
    if (!sprite) return;
    const drawX = deco.x * TILE_SIZE - cx;
    const drawY = deco.y * TILE_SIZE - cy - (sprite.height - TILE_SIZE);
    ctx.drawImage(sprite, drawX, drawY);
  }

  drawRoadmapItem(ctx, item, cx, cy) {
    const sprite = this.decos[item.icon];
    // For tent/tower with PixelLab sprites, allow rendering even without deco fallback
    if (!sprite && item.icon !== 'tent' && item.icon !== 'tower') return;
    if (!sprite && item.icon === 'tower' && !this.castleSprites[item.id] && !this.castleSprite) return;
    if (!sprite && item.icon === 'tent' && !this.tentSprites[item.id] && !this.tentSprite) return;

    const drawX = item.mapX * TILE_SIZE - cx;
    const drawY = item.mapY * TILE_SIZE - cy;
    const centerX = drawX + TILE_SIZE / 2;

    // Glow when character is nearby (interactive landmark)
    const nearbyItem = this.character.getNearbyItem(80);
    if (nearbyItem === item && item.icon !== 'dragon') {
      const glowPhase = Math.sin(this.time * 0.08) * 0.15 + 0.25;
      ctx.save();
      ctx.globalAlpha = glowPhase;
      const glowR = 28;
      const gx = centerX;
      const gy = drawY + TILE_SIZE / 2;
      const grad = ctx.createRadialGradient(gx, gy, 0, gx, gy, glowR);
      grad.addColorStop(0, item.status === 'shipped' ? 'rgba(64,224,64,0.5)' : 'rgba(240,192,64,0.5)');
      grad.addColorStop(1, 'transparent');
      ctx.fillStyle = grad;
      ctx.fillRect(centerX - glowR, drawY - glowR, glowR * 2, glowR * 2);
      ctx.restore();
    }

    // Dragon special handling
    if (item.icon === 'dragon') {
      const dragonScale = 1.5; // Scale up the dragon for boss presence
      const dw = sprite.width * dragonScale;
      const dh = sprite.height * dragonScale;
      const dragonCX = drawX + TILE_SIZE / 2;
      const dragonCY = drawY + TILE_SIZE / 2;

      if (this.dragonSlain) {
        // Draw fallen dragon (flipped, faded)
        ctx.globalAlpha = 0.5;
        ctx.save();
        ctx.translate(dragonCX, dragonCY);
        ctx.scale(1, -1);
        ctx.drawImage(sprite, -dw / 2, -dh / 2, dw, dh);
        ctx.restore();
        ctx.globalAlpha = 1;

        // Victory flag
        ctx.drawImage(this.decos.flag, drawX + 32, drawY - 32);
      } else {
        // Breathing animation
        const breathOffset = Math.sin(this.time * 0.05) * 2;
        const hitFlash = this.dragonHitTimer > 0;
        if (hitFlash) {
          ctx.globalAlpha = 0.5 + Math.random() * 0.5;
          this.dragonHitTimer--;
        }
        ctx.drawImage(sprite, dragonCX - dw / 2, dragonCY - dh / 2 + breathOffset - 16, dw, dh);
        ctx.globalAlpha = 1;

        // Fire breath particles
        if (this.dragonFightActive && this.time % 8 === 0) {
          this.particles.emit(
            item.mapX * TILE_SIZE + 90,
            item.mapY * TILE_SIZE + 36,
            3,
            { colors: ['#f08020', '#f0c040', '#ff4020'], speed: 4, life: 20 }
          );
        }
      }
      return;
    }

    // Draw the icon
    if (item.icon === 'tower') {
      // Use per-item castle sprite from the castle grid
      const itemCastle = this.castleSprites[item.id] || this.castleSprite;
      let castleDrawX, castleDrawY, castleW, castleH;
      if (itemCastle) {
        const cW = itemCastle.width;
        const cH = itemCastle.height;
        const scale = 1.4; // Scale up slightly for visibility
        castleW = cW * scale;
        castleH = cH * scale;
        castleDrawX = centerX - castleW / 2;
        castleDrawY = drawY - castleH + TILE_SIZE + 4;
        ctx.drawImage(itemCastle, castleDrawX, castleDrawY, castleW, castleH);
      } else {
        ctx.drawImage(sprite, drawX - TILE_SIZE/2, drawY - sprite.height + TILE_SIZE);
        castleDrawX = drawX - TILE_SIZE/2;
        castleDrawY = drawY - sprite.height + TILE_SIZE;
        castleW = sprite.width;
        castleH = sprite.height;
      }

    } else if (item.icon === 'tent') {
      // Use per-item tent sprite from the tent grid
      const itemTent = this.tentSprites[item.id] || this.tentSprite;
      let tentDrawX, tentDrawY, tentW, tentH;
      if (itemTent) {
        const tW = itemTent.width;
        const tH = itemTent.height;
        const scale = 1.2;
        tentW = tW * scale;
        tentH = tH * scale;
        tentDrawX = centerX - tentW / 2;
        tentDrawY = drawY - tentH + TILE_SIZE + 4;
        ctx.drawImage(itemTent, tentDrawX, tentDrawY, tentW, tentH);
      } else {
        // Fallback to old chest sprite
        const fallbackSprite = this.decos['chest'];
        if (fallbackSprite) ctx.drawImage(fallbackSprite, drawX, drawY);
        tentDrawX = drawX;
        tentDrawY = drawY;
        tentW = TILE_SIZE;
        tentH = TILE_SIZE;
      }
    } else if (item.icon === 'chest') {
      ctx.drawImage(sprite, drawX, drawY);
    } else if (item.icon === 'flag') {
      const flagWave = Math.sin(this.time * 0.1) * 2;
      ctx.drawImage(sprite, drawX, drawY - TILE_SIZE + flagWave);
    } else if (item.icon === 'bow') {
      // Only draw bow on map if character hasn't picked it up yet
      if (!this.character.hasBow) {
        const hover = Math.sin(this.time * 0.06) * 3;
        // Glow pulse around bow
        const glowAlpha = 0.15 + Math.sin(this.time * 0.04) * 0.1;
        ctx.fillStyle = `rgba(255, 220, 80, ${glowAlpha})`;
        ctx.beginPath();
        ctx.arc(centerX, drawY - TILE_SIZE / 2 + hover, 20, 0, Math.PI * 2);
        ctx.fill();
        ctx.drawImage(sprite, drawX, drawY - TILE_SIZE + hover);
      }
    }

    // Draw numbered pixelated banner/shield to the right of each stop (not milestones)
    if (typeof item.id === 'number') {
      // Position the banner to the bottom-right of the icon
      const bannerX = centerX + 14;
      const bannerY = drawY + 6;
      const bw = 18; // banner width
      const bh = 20; // banner height (before pennant tail)
      const px = 2;  // pixel size for pixelated look

      const isShipped = item.status === 'shipped';
      const darkColor = isShipped ? '#1a5a1a' : '#5a3810';
      const mainColor = isShipped ? '#2a8a2a' : '#7a5020';
      const lightColor = isShipped ? '#40c040' : '#c09030';
      const borderColor = isShipped ? '#30d030' : '#d0a040';
      const numColor = '#fff';

      // Banner pole (small vertical line on left)
      ctx.fillStyle = '#8a7050';
      ctx.fillRect(bannerX - 2, bannerY - 4, px, bh + 8);
      ctx.fillStyle = '#a08860';
      ctx.fillRect(bannerX - 2, bannerY - 4, 1, bh + 8);
      // Pole cap
      ctx.fillStyle = '#d0b060';
      ctx.fillRect(bannerX - 3, bannerY - 6, px + 2, px);

      // Banner body — pixelated rectangle with inner border
      // Outer border (dark)
      ctx.fillStyle = darkColor;
      ctx.fillRect(bannerX, bannerY, bw, bh);
      // Inner fill
      ctx.fillStyle = mainColor;
      ctx.fillRect(bannerX + px, bannerY + px, bw - px * 2, bh - px * 2);
      // Top highlight
      ctx.fillStyle = lightColor;
      ctx.fillRect(bannerX + px, bannerY + px, bw - px * 2, px);
      // Left highlight
      ctx.fillRect(bannerX + px, bannerY + px, px, bh - px * 3);
      // Bottom shadow
      ctx.fillStyle = darkColor;
      ctx.fillRect(bannerX + px, bannerY + bh - px * 2, bw - px * 2, px);

      // Pennant tail (two triangular points at bottom)
      ctx.fillStyle = mainColor;
      for (let i = 0; i < 4; i++) {
        // Left point
        ctx.fillRect(bannerX + i * px, bannerY + bh + i * px, px, px);
        // Right point
        ctx.fillRect(bannerX + bw - (i + 1) * px, bannerY + bh + i * px, px, px);
      }
      // Darken outer edges of pennant
      ctx.fillStyle = darkColor;
      ctx.fillRect(bannerX, bannerY + bh, px, px);
      ctx.fillRect(bannerX + bw - px, bannerY + bh, px, px);

      // Corner accents (pixelated rivets)
      ctx.fillStyle = borderColor;
      ctx.fillRect(bannerX + px, bannerY + px, px, px);
      ctx.fillRect(bannerX + bw - px * 2, bannerY + px, px, px);
      ctx.fillRect(bannerX + px, bannerY + bh - px * 2, px, px);
      ctx.fillRect(bannerX + bw - px * 2, bannerY + bh - px * 2, px, px);

      // Number text centered in banner
      ctx.font = '8px "Press Start 2P"';
      ctx.fillStyle = numColor;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      // Add tiny shadow for readability
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillText(String(item.id), bannerX + bw / 2 + 1, bannerY + bh / 2 + 1);
      ctx.fillStyle = numColor;
      ctx.fillText(String(item.id), bannerX + bw / 2, bannerY + bh / 2);
      ctx.textAlign = 'start';
      ctx.textBaseline = 'alphabetic';
    }
  }

  drawPitfall(ctx, pitfall, cx, cy) {
    const sprite = this.decos.pitfall;
    if (!sprite) return;

    const drawX = pitfall.mapX * TILE_SIZE - cx;
    const drawY = pitfall.mapY * TILE_SIZE - cy;
    const centerX = drawX + TILE_SIZE / 2;
    const centerY = drawY + TILE_SIZE / 2;

    if (this.getNearbyPitfall(78) === pitfall) {
      const glowR = 22;
      ctx.save();
      ctx.globalAlpha = 0.25 + Math.sin(this.time * 0.08) * 0.1;
      const grad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, glowR);
      grad.addColorStop(0, 'rgba(255, 90, 90, 0.7)');
      grad.addColorStop(1, 'transparent');
      ctx.fillStyle = grad;
      ctx.fillRect(centerX - glowR, centerY - glowR, glowR * 2, glowR * 2);
      ctx.restore();
    }

    const wobble = Math.sin(this.time * 0.06 + pitfall.mapX) * 1.5;
    ctx.drawImage(sprite, drawX, drawY - 4 + wobble);
  }

  drawItemLabels(ctx, cx, cy) {
    ctx.font = '7px "Press Start 2P"';
    ctx.textAlign = 'center';

    for (const item of ROADMAP_ITEMS) {
      if (item.status === 'milestone') continue;

      const drawX = item.mapX * TILE_SIZE + TILE_SIZE/2 - cx;
      const drawY = item.mapY * TILE_SIZE - cy;

      // Only show labels when somewhat nearby
      const dist = Math.sqrt(
        (this.character.x - item.mapX * TILE_SIZE) ** 2 +
        (this.character.y - item.mapY * TILE_SIZE) ** 2
      );

      const maxDist = 500;
      if (dist > maxDist) continue;

      const alpha = Math.min(1, (maxDist - dist) / 200);

      // Full label, no truncation — wrap long text into multiple lines
      const fullLabel = item.title.replace(/\n/g, ' ');
      const maxWidth = 100;
      const words = fullLabel.split(' ');
      const lines = [];
      let line = '';
      for (const w of words) {
        const test = line ? line + ' ' + w : w;
        if (ctx.measureText(test).width <= maxWidth) {
          line = test;
        } else {
          if (line) lines.push(line);
          line = w;
        }
      }
      if (line) lines.push(line);

      const lineHeight = 9;
      const labelY = item.icon === 'tower' ? drawY - 36 : drawY - 18;
      const labelH = lines.length * lineHeight + 4;
      let labelW = 0;
      for (const ln of lines) {
        labelW = Math.max(labelW, ctx.measureText(ln).width + 12);
      }

      ctx.globalAlpha = alpha * 0.85;
      ctx.fillStyle = 'rgba(0,0,0,0.75)';
      ctx.fillRect(drawX - labelW/2, labelY - 4, labelW, labelH);

      ctx.globalAlpha = alpha;
      ctx.fillStyle = item.status === 'shipped' ? '#90e090' : '#e8d060';
      lines.forEach((ln, i) => {
        ctx.fillText(ln, drawX, labelY + lineHeight * (i + 1) - 2);
      });

      ctx.globalAlpha = 1;
    }

    ctx.textAlign = 'start';
  }

  renderMinimap() {
    const mCtx = this.minimapCtx;
    const mW = this.minimapCanvas.width;
    const mH = this.minimapCanvas.height;
    const scaleX = mW / (MAP_COLS * TILE_SIZE);
    const scaleY = mH / (MAP_ROWS * TILE_SIZE);

    mCtx.fillStyle = '#1a1a2a';
    mCtx.fillRect(0, 0, mW, mH);

    // Draw simplified map
    for (let y = 0; y < MAP_ROWS; y++) {
      for (let x = 0; x < MAP_COLS; x++) {
        const tile = this.worldMap.grid[y][x];
        let color = '#2a5a2a';
        if (tile === 'path') color = '#a08050';
        else if (tile === 'water') color = '#2050a0';
        else if (tile === 'darkGrass') color = '#1a3a1a';
        else if (tile === 'stone') color = '#505060';
        else if (tile === 'volcanic') color = '#3a1515';

        mCtx.fillStyle = color;
        mCtx.fillRect(
          Math.floor(x * TILE_SIZE * scaleX),
          Math.floor(y * TILE_SIZE * scaleY),
          Math.ceil(TILE_SIZE * scaleX) + 1,
          Math.ceil(TILE_SIZE * scaleY) + 1
        );
      }
    }

    // Draw roadmap items on minimap
    for (const item of ROADMAP_ITEMS) {
      const mx = item.mapX * TILE_SIZE * scaleX;
      const my = item.mapY * TILE_SIZE * scaleY;
      if (item.status === 'shipped') {
        mCtx.fillStyle = '#40e040';
      } else if (item.status === 'upcoming') {
        mCtx.fillStyle = '#f0c040';
      } else if (item.icon === 'dragon') {
        mCtx.fillStyle = '#c03030';
      } else {
        mCtx.fillStyle = '#f0c040';
      }
      mCtx.fillRect(mx - 2, my - 2, 5, 5);
    }

    // Draw pitfalls on minimap
    for (const pitfall of PITFALLS) {
      const mx = pitfall.mapX * TILE_SIZE * scaleX;
      const my = pitfall.mapY * TILE_SIZE * scaleY;
      mCtx.fillStyle = '#c04040';
      mCtx.fillRect(mx - 2, my - 2, 5, 5);
    }
  }

  updateMinimapDot() {
    // Refresh the static minimap, then draw the player dot
    this.renderMinimap();

    const mCtx = this.minimapCtx;
    const scaleX = this.minimapCanvas.width / (MAP_COLS * TILE_SIZE);
    const scaleY = this.minimapCanvas.height / (MAP_ROWS * TILE_SIZE);
    const px = this.character.x * scaleX;
    const py = this.character.y * scaleY;

    // Player dot (blinking)
    mCtx.fillStyle = this.time % 30 < 20 ? '#fff' : '#f0c040';
    mCtx.fillRect(px - 2, py - 2, 4, 4);

    // Camera viewport rectangle (accounting for zoom)
    mCtx.strokeStyle = 'rgba(255,255,255,0.3)';
    mCtx.lineWidth = 1;
    mCtx.strokeRect(
      this.cameraX * scaleX,
      this.cameraY * scaleY,
      (this.width / this.zoom) * scaleX,
      (this.height / this.zoom) * scaleY
    );
  }

  // Load doctor NPC sprites from assets (generated by PixelLab)
  async loadDoctorSprites() {
    const loadImg = (src) => new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => resolve(null);
      img.src = src;
    });
    // Try to load doctor sprites — graceful fallback if not found
    const doctorDirs = ['assets/npcs/doctor1', 'assets/npcs/doctor2', 'assets/npcs/doctor3'];
    for (const dir of doctorDirs) {
      const south = await loadImg(`${dir}/south.png`);
      if (south) {
        this.doctorSprites.push(south);
      }
    }
  }

  // Spawn celebrating doctor NPCs near a milestone
  spawnDoctors(milestoneX, milestoneY) {
    this.doctorsSpawned = true;
    const positions = [
      { x: milestoneX + 3, y: milestoneY - 2 },
      { x: milestoneX + 4, y: milestoneY + 1 },
      { x: milestoneX + 2, y: milestoneY + 3 },
      { x: milestoneX - 2, y: milestoneY + 2 },
    ];
    const messages = [
      "We love your app!",
      "Thank you, Bard!",
      "Our hero!",
      "Amazing work!"
    ];
    for (let i = 0; i < positions.length; i++) {
      this.doctors.push({
        x: positions[i].x * TILE_SIZE + TILE_SIZE / 2,
        y: positions[i].y * TILE_SIZE + TILE_SIZE / 2,
        message: messages[i],
        spriteIdx: i % Math.max(1, this.doctorSprites.length),
        bouncePhase: Math.random() * Math.PI * 2,
        spawnTime: this.time
      });
    }
  }

  // Draw doctor NPCs with speech bubbles
  drawDoctors(ctx, cx, cy) {
    for (const doc of this.doctors) {
      const sx = doc.x - cx;
      const sy = doc.y - cy;
      const bounce = Math.sin(this.time * 0.08 + doc.bouncePhase) * 2;

      // Draw doctor sprite or fallback circle
      if (this.doctorSprites[doc.spriteIdx]) {
        const sprite = this.doctorSprites[doc.spriteIdx];
        ctx.drawImage(sprite, sx - 24, sy - 40 + bounce);
      } else {
        // Fallback: simple doctor pixel art
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(sx - 8, sy - 24 + bounce, 16, 20);
        ctx.fillStyle = '#f0d0a0';
        ctx.fillRect(sx - 6, sy - 32 + bounce, 12, 10);
        ctx.fillStyle = '#e03030';
        ctx.fillRect(sx - 2, sy - 18 + bounce, 4, 6);
        ctx.fillRect(sx - 4, sy - 16 + bounce, 8, 2);
      }

      // Speech bubble
      const fadeIn = Math.min(1, (this.time - doc.spawnTime) / 60);
      if (fadeIn > 0.5) {
        ctx.globalAlpha = Math.min(1, (fadeIn - 0.5) * 2);
        const msg = doc.message;
        ctx.font = '5px "Press Start 2P"';
        const tw = ctx.measureText(msg).width;
        const bw = tw + 8;
        const bh = 14;
        const bx = sx - bw / 2;
        const by = sy - 50 + bounce;

        // Bubble background
        ctx.fillStyle = '#fff';
        ctx.fillRect(bx, by, bw, bh);
        ctx.fillStyle = '#000';
        ctx.fillRect(bx - 1, by + 1, 1, bh - 2);
        ctx.fillRect(bx + bw, by + 1, 1, bh - 2);
        ctx.fillRect(bx + 1, by - 1, bw - 2, 1);
        ctx.fillRect(bx + 1, by + bh, bw - 2, 1);
        // Tail
        ctx.fillStyle = '#fff';
        ctx.fillRect(sx - 2, by + bh, 4, 3);

        // Text
        ctx.fillStyle = '#222';
        ctx.textAlign = 'center';
        ctx.fillText(msg, sx, by + 9);
        ctx.textAlign = 'start';
        ctx.globalAlpha = 1;
      }
    }
  }

  // Draw dragon speech bubble during opening scene
  drawDragonSpeech(ctx, cx, cy) {
    if (this.gamePhase !== 'opening_dragon') return;
    const dragon = ROADMAP_ITEMS.find(i => i.id === 'milestone2');
    const dx = dragon.mapX * TILE_SIZE + TILE_SIZE / 2 - cx;
    const dy = dragon.mapY * TILE_SIZE - cy - 30;

    const text = this.openingText.substring(0, this.openingTextIndex);
    if (text.length === 0) return;

    // Word wrap
    ctx.font = '6px "Press Start 2P"';
    const maxW = 180;
    const words = text.split(' ');
    const lines = [];
    let line = '';
    for (const word of words) {
      const test = line ? line + ' ' + word : word;
      if (ctx.measureText(test).width > maxW) {
        if (line) lines.push(line);
        line = word;
      } else {
        line = test;
      }
    }
    if (line) lines.push(line);

    const lineH = 12;
    const bw = maxW + 16;
    const bh = lines.length * lineH + 16;
    const bx = dx - bw / 2;
    const by = dy - bh;

    // Bubble
    ctx.fillStyle = '#fff';
    ctx.fillRect(bx, by, bw, bh);
    ctx.fillStyle = '#000';
    ctx.fillRect(bx - 1, by + 1, 1, bh - 2);
    ctx.fillRect(bx + bw, by + 1, 1, bh - 2);
    ctx.fillRect(bx + 1, by - 1, bw - 2, 1);
    ctx.fillRect(bx + 1, by + bh, bw - 2, 1);
    // Tail pointing down to dragon
    ctx.fillStyle = '#fff';
    ctx.fillRect(dx - 4, by + bh, 8, 6);
    ctx.fillRect(dx - 2, by + bh + 6, 4, 4);

    // Text
    ctx.fillStyle = '#c03030';
    ctx.textAlign = 'center';
    for (let i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], dx, by + 12 + i * lineH);
    }
    ctx.textAlign = 'start';
  }

  // Show/hide roadmap summary overlay
  showRoadmapOverlay() {
    this.roadmapOverlayVisible = true;
    const container = document.getElementById('roadmap-scroll-content');
    let html = '<div class="roadmap-title">THE ROADMAP</div>';
    html += '<div class="roadmap-section-title">FEATURE ROADMAP</div>';
    for (const item of ROADMAP_ITEMS) {
      if (item.status === 'milestone') continue;
      const statusClass = item.status === 'shipped' ? 'shipped' : 'upcoming';
      const statusText = item.status === 'shipped' ? '✓ SHIPPED' : '★ UPCOMING';
      html += `<div class="roadmap-item">`;
      html += `<div class="ri-status ${statusClass}">${statusText}</div>`;
      html += `<div class="ri-title">${item.id}. ${item.title}</div>`;
      html += `<div class="ri-desc">${item.description}</div>`;
      if (item.docsUrl) {
        html += `<a class="ri-link" href="${item.docsUrl}" target="_blank" rel="noopener noreferrer">EXPLORE DOCS →</a>`;
      }
      html += `</div>`;
    }
    html += '<div class="roadmap-section-title">PITFALLS TO AVOID IN PRODUCTION</div>';
    for (const pitfall of PITFALLS) {
      html += `<div class="roadmap-item">`;
      html += `<div class="ri-status pitfall">! PITFALL</div>`;
      html += `<div class="ri-title">${pitfall.id}. ${pitfall.title}</div>`;
      html += `<div class="ri-desc"><span class="ri-label">Risk:</span> ${pitfall.risk}<br><span class="ri-label">Mitigation:</span> ${pitfall.mitigation}</div>`;
      html += `</div>`;
    }
    container.innerHTML = html;
    document.getElementById('roadmap-overlay').classList.add('visible');
  }

  hideRoadmapOverlay() {
    this.roadmapOverlayVisible = false;
    document.getElementById('roadmap-overlay').classList.remove('visible');
    // If game is over, re-show the victory screen (force reflow to replay fadeIn animation)
    if (this.gamePhase === 'victory' || this.dragonSlain) {
      const vs = document.getElementById('victory-screen');
      vs.classList.remove('visible');
      void vs.offsetWidth; // force reflow so animation replays
      vs.classList.add('visible');
    }
  }

  loop() {
    this.update();
    this.draw();
    requestAnimationFrame(() => this.loop());
  }
}

// ============================================================
// GLOBAL FUNCTIONS
// ============================================================
function closePanel() {
  game.closePanel();
}

// Start the game
const game = new Game();

  </script>
</body>
</html>
